diff --git a/.vscode/launch.json b/.vscode/launch.json
new file mode 100644
index 0000000..4b6a3f5
--- /dev/null
+++ b/.vscode/launch.json
@@ -0,0 +1,61 @@
+{
+  "version": "0.2.0",
+  "configurations": [
+    {
+      "name": "Debug Local File",
+      "type": "Ruby",
+      "request": "launch",
+      "cwd": "${workspaceRoot}",
+      "program": "${workspaceRoot}/main.rb"
+    },
+    {
+      "name": "Listen for rdebug-ide",
+      "type": "Ruby",
+      "request": "attach",
+      "cwd": "${workspaceRoot}",
+      "remoteHost": "127.0.0.1",
+      "remotePort": "1234",
+      "remoteWorkspaceRoot": "${workspaceRoot}"
+    },
+    {
+      "name": "Rails server",
+      "type": "Ruby",
+      "request": "launch",
+      "cwd": "${workspaceRoot}",
+      "program": "${workspaceRoot}/bin/rails",
+      "args": [
+        "server"
+      ]
+    },
+    {
+      "name": "RSpec - all",
+      "type": "Ruby",
+      "request": "launch",
+      "cwd": "${workspaceRoot}",
+      "program": "${workspaceRoot}/bin/rspec",
+      "args": [
+        "-I",
+        "${workspaceRoot}"
+      ]
+    },
+    {
+      "name": "RSpec - active spec file only",
+      "type": "Ruby",
+      "request": "launch",
+      "cwd": "${workspaceRoot}",
+      "program": "${workspaceRoot}/bin/rspec",
+      "args": [
+        "-I",
+        "${workspaceRoot}",
+        "${file}"
+      ]
+    },
+    {
+      "name": "Cucumber",
+      "type": "Ruby",
+      "request": "launch",
+      "cwd": "${workspaceRoot}",
+      "program": "${workspaceRoot}/bin/cucumber"
+    }
+  ]
+}
\ No newline at end of file
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5817675..30499d7 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,6 @@
 ## Master
 
+* add `file` and `line` optional parameters to methods on the messaging plugin
 * Show appropriate error message when GitHub repo was moved - KrauseFx
 * `danger plugins json [gem]` will now give gem metadata too - orta
 
diff --git a/Dangerfile b/Dangerfile
index 16e75d7..50e35a9 100644
--- a/Dangerfile
+++ b/Dangerfile
@@ -4,7 +4,7 @@ has_app_changes = !git.modified_files.grep(/lib/).empty?
 has_test_changes = !git.modified_files.grep(/spec/).empty?
 
 if has_app_changes && !has_test_changes
-  warn "Tests were not updated"
+  warn("Tests were not updated", sticky: false)
 end
 
 # Make a note about contributors not in the organization
@@ -27,7 +27,7 @@ end
 declared_trivial = (github.pr_title + github.pr_body).include?("#trivial") || !has_app_changes
 
 if !git.modified_files.include?("CHANGELOG.md") && !declared_trivial
-  fail("Please include a CHANGELOG entry. \nYou can find it at [CHANGELOG.md](https://github.com/danger/danger/blob/master/CHANGELOG.md).")
+  fail("Please include a CHANGELOG entry. \nYou can find it at [CHANGELOG.md](https://github.com/danger/danger/blob/master/CHANGELOG.md).", sticky: false)
 end
 
 # Docs are critical, so let's re-run the docs part of the specs and show any issues:
diff --git a/Rakefile b/Rakefile
index 231b53c..e1c368e 100644
--- a/Rakefile
+++ b/Rakefile
@@ -28,3 +28,8 @@ task :spec_docs do
   sh "danger plugins lint #{core_plugins.join ' '}"
   sh "danger systems ci_docs"
 end
+
+desc "I do this so often now, better to just handle it here"
+task :guard do |task|
+  sh "bundle exec guard"
+end
diff --git a/lib/danger/comment_generators/github_inline.md.erb b/lib/danger/comment_generators/github_inline.md.erb
new file mode 100644
index 0000000..aa7a023
--- /dev/null
+++ b/lib/danger/comment_generators/github_inline.md.erb
@@ -0,0 +1,26 @@
+<%- @tables.each do |table| -%>
+  <%- if table[:content].any? -%>
+<table data-meta="generated_by_<%= @danger_id %>">
+  <tbody>
+    <%- table[:content].each do |violation| -%>
+    <tr>
+      <td>:<%= table[:emoji] %>:</td>
+      <td width="100%" data-sticky="<%= violation.sticky %>"><%= "<del>" if table[:resolved] %><%= violation.message %><%= "</del>" if table[:resolved] %></td>
+    </tr>
+    <%- end -%>
+  </tbody>
+</table>
+  <%- end -%>
+<%- end -%>
+
+<%- @markdowns.each do |current| -%>
+<%= current %>
+<%# the previous line has to be aligned far to the left, otherwise markdown can break easily %>
+<%- end -%>
+<%# We need to add the generated_by_ to identify comments from danger. But with inlines %>
+<%# it might be a little annoying, so we set on the table, but if we have markdown we add the footer anyway %>
+<%- if @markdowns.count > 0 -%>
+<p align="right" data-meta="generated_by_<%= @danger_id %>">
+  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
+</p>
+<%- end -%>
diff --git a/lib/danger/danger_core/dangerfile.rb b/lib/danger/danger_core/dangerfile.rb
index a2050d1..b64ae8b 100644
--- a/lib/danger/danger_core/dangerfile.rb
+++ b/lib/danger/danger_core/dangerfile.rb
@@ -203,7 +203,8 @@ def parse(path, contents = nil)
 
     def print_results
       status = status_report
-      return if (status[:errors] + status[:warnings] + status[:messages] + status[:markdowns]).count.zero?
+      violations = violation_report
+      return if (violations[:errors] + violations[:warnings] + violations[:messages] + status[:markdowns]).count.zero?
 
       ui.section("Results:") do
         [:errors, :warnings, :messages].each do |key|
@@ -216,14 +217,15 @@ def print_results
                   else
                     formatted
                   end
-          rows = status[key]
+          rows = violations[key]
           print_list(title, rows)
         end
 
         if status[:markdowns].count > 0
-          ui.section("Markdown:") do
+          ui.title("Markdown:") do
             status[:markdowns].each do |current_markdown|
-              ui.puts current_markdown
+              ui.puts "#{current_markdown.file}\#L#{current_markdown.line}" if current_markdown.file && current_markdown.line
+              ui.puts current_markdown.message
             end
           end
         end
@@ -235,7 +237,13 @@ def print_results
     def print_list(title, rows)
       ui.title(title) do
         rows.each do |row|
-          ui.puts("- [ ] #{row}")
+          if row.file && row.line
+            path = "#{row.file}\#L#{row.line}: "
+          else
+            path = ""
+          end
+
+          ui.puts("- [ ] #{path}#{row.message}")
         end
       end unless rows.empty?
     end
diff --git a/lib/danger/danger_core/messages/markdown.rb b/lib/danger/danger_core/messages/markdown.rb
new file mode 100644
index 0000000..badfdda
--- /dev/null
+++ b/lib/danger/danger_core/messages/markdown.rb
@@ -0,0 +1,28 @@
+module Danger
+  class Markdown
+    attr_accessor :message, :file, :line
+
+    def initialize(message, file, line)
+      self.message = message
+      self.file = file
+      self.line = line
+    end
+
+    def ==(other)
+      return false if other.nil?
+      return false unless other.kind_of? self.class
+
+      other.message == message &&
+        other.file == file &&
+        other.line == line
+    end
+
+    def to_s
+      extra = []
+      extra << "file: #{file}" unless file.nil?
+      extra << "line: #{line}" unless line.nil?
+
+      "Markdown #{message} { #{extra.join ', '} }"
+    end
+  end
+end
diff --git a/lib/danger/danger_core/messages/violation.rb b/lib/danger/danger_core/messages/violation.rb
new file mode 100644
index 0000000..33487c3
--- /dev/null
+++ b/lib/danger/danger_core/messages/violation.rb
@@ -0,0 +1,31 @@
+module Danger
+  class Violation
+    attr_accessor :message, :sticky, :file, :line
+
+    def initialize(message, sticky, file, line)
+      self.message = message
+      self.sticky = sticky
+      self.file = file
+      self.line = line
+    end
+
+    def ==(other)
+      return false if other.nil?
+      return false unless other.kind_of? self.class
+
+      other.message == message &&
+        other.sticky == sticky &&
+        other.file == file &&
+        other.line == line
+    end
+
+    def to_s
+      extra = []
+      extra << "sticky: true" if sticky
+      extra << "file: #{file}" unless file.nil?
+      extra << "line: #{line}" unless line.nil?
+
+      "Violation #{message} { #{extra.join ', '} }"
+    end
+  end
+end
diff --git a/lib/danger/danger_core/plugins/dangerfile_messaging_plugin.rb b/lib/danger/danger_core/plugins/dangerfile_messaging_plugin.rb
index b73d101..c48862a 100644
--- a/lib/danger/danger_core/plugins/dangerfile_messaging_plugin.rb
+++ b/lib/danger/danger_core/plugins/dangerfile_messaging_plugin.rb
@@ -1,4 +1,5 @@
-require "danger/danger_core/violation"
+require "danger/danger_core/messages/violation"
+require "danger/danger_core/messages/markdown"
 require "danger/plugin_support/plugin"
 
 module Danger
@@ -38,6 +39,10 @@ module Danger
   #          message << "20 | No documentation | Error \n"
   #          markdown message
   #
+  # @example Adding an inline warning to a file
+  #
+  #          warn("You shouldn't use puts in your Dangerfile", file: "Dangerfile", line: 10)
+  #
   #
   # @see  danger/danger
   # @tags core, messaging
@@ -65,10 +70,14 @@ def self.instance_name
     #
     # @param    [String] message
     #           The markdown based message to be printed below the table
+    # @param    [String] file
+    #           Optional. Path to the file that the message is for.
+    # @param    [String] line
+    #           Optional. The line in the file to present the message in.
     # @return   [void]
     #
-    def markdown(message)
-      @markdowns << message
+    def markdown(message, file: nil, line: nil)
+      @markdowns << Markdown.new(message, file, line)
     end
 
     # @!group Core
@@ -79,10 +88,14 @@ def markdown(message)
     # @param    [Boolean] sticky
     #           Whether the message should be kept after it was fixed,
     #           defaults to `true`.
+    # @param    [String] file
+    #           Optional. Path to the file that the message is for.
+    # @param    [String] line
+    #           Optional. The line in the file to present the message in.
     # @return   [void]
     #
-    def message(message, sticky: true)
-      @messages << Violation.new(message, sticky)
+    def message(message, sticky: true, file: nil, line: nil)
+      @messages << Violation.new(message, sticky, file, line)
     end
 
     # @!group Core
@@ -93,11 +106,15 @@ def message(message, sticky: true)
     # @param    [Boolean] sticky
     #           Whether the message should be kept after it was fixed,
     #           defaults to `true`.
+    # @param    [String] file
+    #           Optional. Path to the file that the message is for.
+    # @param    [String] line
+    #           Optional. The line in the file to present the message in.
     # @return   [void]
     #
-    def warn(message, sticky: true)
+    def warn(message, sticky: true, file: nil, line: nil)
       return if should_ignore_violation(message)
-      @warnings << Violation.new(message, sticky)
+      @warnings << Violation.new(message, sticky, file, line)
     end
 
     # @!group Core
@@ -108,11 +125,15 @@ def warn(message, sticky: true)
     # @param    [Boolean] sticky
     #           Whether the message should be kept after it was fixed,
     #           defaults to `true`.
+    # @param    [String] file
+    #           Optional. Path to the file that the message is for.
+    # @param    [String] line
+    #           Optional. The line in the file to present the message in.
     # @return   [void]
     #
-    def fail(message, sticky: true)
+    def fail(message, sticky: true, file: nil, line: nil)
       return if should_ignore_violation(message)
-      @errors << Violation.new(message, sticky)
+      @errors << Violation.new(message, sticky, file, line)
     end
 
     # @!group Reporting
diff --git a/lib/danger/danger_core/violation.rb b/lib/danger/danger_core/violation.rb
deleted file mode 100644
index c204790..0000000
--- a/lib/danger/danger_core/violation.rb
+++ /dev/null
@@ -1,10 +0,0 @@
-module Danger
-  class Violation
-    attr_accessor :message, :sticky
-
-    def initialize(message, sticky)
-      self.message = message
-      self.sticky = sticky
-    end
-  end
-end
diff --git a/lib/danger/helpers/comments_helper.rb b/lib/danger/helpers/comments_helper.rb
index 0f96cd6..b5fa1d1 100644
--- a/lib/danger/helpers/comments_helper.rb
+++ b/lib/danger/helpers/comments_helper.rb
@@ -1,27 +1,57 @@
 require "kramdown"
+require "danger/helpers/comments_parsing_helper"
+
+# rubocop:disable Metrics/ModuleLength
 
 module Danger
   module Helpers
     module CommentsHelper
+      # This might be a bit weird, but table_kind_from_title is a shared dependency for
+      # parsing and generating. And rubocop was adamant about file size so...
+      include Danger::Helpers::CommentsParsingHelper
+
       def markdown_parser(text)
         Kramdown::Document.new(text, input: "GFM")
       end
 
-      def parse_tables_from_comment(comment)
-        comment.split("</table>")
+      # !@group Extension points
+      # Produces a markdown link to the file the message points to
+      #
+      # request_source implementations are invited to override this method with their
+      # vendor specific link.
+      #
+      # @param [Violation or Markdown] message
+      # @param [Bool] Should hide any generated link created
+      #
+      # @return [String] The Markdown compatible link
+      def markdown_link_to_message(message, _)
+        "#{messages.file}#L#{message.line}"
       end
 
-      def violations_from_table(table)
-        regex = %r{<td data-sticky="true">(?:<del>)?(.*?)(?:</del>)?\s*</td>}im
-        table.scan(regex).flatten.map(&:strip)
+      # !@group Extension points
+      # Determine whether two messages are equivalent
+      #
+      # request_source implementations are invited to override this method.
+      # This is mostly here to enable sources to detect when inlines change only in their
+      # commit hash and not in content per-se. since the link is implementation dependant
+      # so should be the comparision.
+      #
+      # @param [Violation or Markdown] m1
+      # @param [Violation or Markdown] m2
+      #
+      # @return [Boolean] whether they represent the same message
+      def messages_are_equivalent(m1, m2)
+        m1 == m2
       end
 
-      def process_markdown(violation)
-        html = markdown_parser(violation.message).to_html
+      def process_markdown(violation, hide_link = false)
+        message = violation.message
+        message = "#{markdown_link_to_message(violation, hide_link)}#{message}" if violation.file && violation.line
+
+        html = markdown_parser(message).to_html
         # Remove the outer `<p>`, the -5 represents a newline + `</p>`
         html = html[3...-5] if html.start_with? "<p>"
-
-        Violation.new(html, violation.sticky)
+        Violation.new(html, violation.sticky, violation.file, violation.line)
       end
 
       def parse_comment(comment)
@@ -41,50 +71,69 @@ def parse_comment(comment)
       end
 
       def table(name, emoji, violations, all_previous_violations)
-        content = violations.map { |v| process_markdown(v) }.uniq
+        content = violations.map { |v| process_markdown(v) }
+
         kind = table_kind_from_title(name)
         previous_violations = all_previous_violations[kind] || []
-        messages = content.map(&:message)
-        resolved_violations = previous_violations.uniq - messages
+        resolved_violations = previous_violations.reject do |pv|
+          content.select { |v| messages_are_equivalent(v, pv) }.count > 0
+        end
+
+        resolved_messages = resolved_violations.map(&:message).uniq
         count = content.count
 
         {
           name: name,
           emoji: emoji,
           content: content,
-          resolved: resolved_violations,
+          resolved: resolved_messages,
           count: count
         }
       end
 
-      def table_kind_from_title(title)
-        if title =~ /error/i
-          :error
-        elsif title =~ /warning/i
-          :warning
-        elsif title =~ /message/i
-          :message
-        end
-      end
-
-      def generate_comment(warnings: [], errors: [], messages: [], markdowns: [], previous_violations: {}, danger_id: "danger", template: "github")
+      def apply_template(tables: [], markdowns: [], danger_id: "danger", template: "github")
         require "erb"
 
         md_template = File.join(Danger.gem_path, "lib/danger/comment_generators/#{template}.md.erb")
 
         # erb: http://www.rrn.dk/rubys-erb-templating-system
         # for the extra args: http://stackoverflow.com/questions/4632879/erb-template-removing-the-trailing-line
-        @tables = [
-          table("Error", "no_entry_sign", errors, previous_violations),
-          table("Warning", "warning", warnings, previous_violations),
-          table("Message", "book", messages, previous_violations)
-        ]
-        @markdowns = markdowns
+        @tables = tables
+        @markdowns = markdowns.map(&:message)
         @danger_id = danger_id
 
         return ERB.new(File.read(md_template), 0, "-").result(binding)
       end
 
+      def generate_comment(warnings: [], errors: [], messages: [], markdowns: [], previous_violations: {}, danger_id: "danger", template: "github")
+        apply_template(
+          tables: [
+            table("Error", "no_entry_sign", errors, previous_violations),
+            table("Warning", "warning", warnings, previous_violations),
+            table("Message", "book", messages, previous_violations)
+          ],
+          markdowns: markdowns,
+          danger_id: danger_id,
+          template: template
+        )
+      end
+
+      def generate_inline_comment_body(emoji, message, danger_id: "danger", resolved: false, template: "github")
+        apply_template(
+          tables: [{ content: [message], resolved: resolved, emoji: emoji }],
+          danger_id: danger_id,
+          template: "#{template}_inline"
+        )
+      end
+
+      def generate_inline_markdown_body(markdown, danger_id: "danger", template: "github")
+        apply_template(
+          markdowns: [markdown],
+          danger_id: danger_id,
+          template: "#{template}_inline"
+        )
+      end
+
       def generate_description(warnings: nil, errors: nil)
         if errors.empty? && warnings.empty?
           return "All green. #{random_compliment}"
diff --git a/lib/danger/helpers/comments_parsing_helper.rb b/lib/danger/helpers/comments_parsing_helper.rb
new file mode 100644
index 0000000..2fe5987
--- /dev/null
+++ b/lib/danger/helpers/comments_parsing_helper.rb
@@ -0,0 +1,52 @@
+module Danger
+  module Helpers
+    module CommentsParsingHelper
+      # !@group Extension points
+      # Produces a message-like from a row in a comment table
+      #
+      # @param [String] row
+      #        The content of the row in the table
+      #
+      # @return [Violation or Markdown] the extracted message
+      def parse_message_from_row(row)
+        Violation.new(row, true, nil, nil)
+      end
+
+      def parse_tables_from_comment(comment)
+        comment.split("</table>")
+      end
+
+      def violations_from_table(table)
+        row_regex = %r{<td data-sticky="true">(?:<del>)?(.*?)(?:</del>)?\s*</td>}im
+        table.scan(row_regex).flatten.map do |row|
+          parse_message_from_row(row.strip)
+        end
+      end
+
+      def parse_comment(comment)
+        tables = parse_tables_from_comment(comment)
+        violations = {}
+        tables.each do |table|
+          next unless table =~ %r{<th width="100%"(.*?)</th>}im
+          title = Regexp.last_match(1)
+          kind = table_kind_from_title(title)
+          next unless kind
+
+          violations[kind] = violations_from_table(table)
+        end
+
+        violations.reject { |_, v| v.empty? }
+      end
+
+      def table_kind_from_title(title)
+        if title =~ /error/i
+          :error
+        elsif title =~ /warning/i
+          :warning
+        elsif title =~ /message/i
+          :message
+        end
+      end
+    end
+  end
+end
diff --git a/lib/danger/request_source/github.rb b/lib/danger/request_source/github.rb
index b122911..e0aff3d 100644
--- a/lib/danger/request_source/github.rb
+++ b/lib/danger/request_source/github.rb
@@ -104,10 +104,33 @@ def update_pull_request!(warnings: [], errors: [], messages: [], markdowns: [],
           # Just remove the comment, if there's nothing to say.
           delete_old_comments!(danger_id: danger_id)
         else
-          body = generate_comment(warnings: warnings,
-                                    errors: errors,
-                                  messages: messages,
-                                 markdowns: markdowns,
+
+          cmp = proc do |a, b|
+            next -1 unless a.file
+            next 1 unless b.file
+
+            next a.line <=> b.line if a.file == b.file
+            next a.file <=> b.file
+          end
+
+          # Sort to group inline comments by file
+          # We copy because we need to mutate this arrays for inlines
+          comment_warnings = warnings.sort(&cmp)
+          comment_errors = errors.sort(&cmp)
+          comment_messages = messages.sort(&cmp)
+          comment_markdowns = markdowns.sort(&cmp)
+
+          submit_inline_comments!(warnings: comment_warnings,
+                                    errors: comment_errors,
+                                  messages: comment_messages,
+                                 markdowns: comment_markdowns,
+                       previous_violations: previous_violations,
+                                 danger_id: danger_id)
+
+          body = generate_comment(warnings: comment_warnings,
+                                    errors: comment_errors,
+                                  messages: comment_messages,
+                                 markdowns: comment_markdowns,
                        previous_violations: previous_violations,
                                  danger_id: danger_id,
                                   template: "github")
@@ -124,7 +147,7 @@ def update_pull_request!(warnings: [], errors: [], messages: [], markdowns: [],
         # Note: this can terminate the entire process.
         submit_pull_request_status!(warnings: warnings,
                                       errors: errors,
-                                 details_url: comment_result["html_url"])
+                                 details_url: comment_result[:html_url])
       end
 
       def submit_pull_request_status!(warnings: [], errors: [], details_url: [])
@@ -170,6 +193,182 @@ def delete_old_comments!(except: nil, danger_id: "danger")
         end
       end
 
+      def submit_inline_comments!(warnings: [], errors: [], messages: [], markdowns: [], previous_violations: [], danger_id: "danger")
+        filter = proc do |v|
+          v.file && v.line
+        end
+
+        # Avoid doing any fetchs if there's no inline comments
+        return if (warnings + errors + messages).select(&filter).empty?
+
+        diff_lines = self.pr_diff.lines
+        pr_comments = client.pull_request_comments(ci_source.repo_slug, ci_source.pull_request_id)
+        danger_comments = pr_comments.select { |comment| comment[:body].include?("generated_by_#{danger_id}") }
+        non_danger_comments = pr_comments - danger_comments
+
+        submit_inline_comments_for_kind!("warning", warnings, diff_lines, danger_comments, previous_violations[:warning], danger_id: danger_id)
+        submit_inline_comments_for_kind!("no_entry_sign", errors, diff_lines, danger_comments, previous_violations[:error], danger_id: danger_id)
+        submit_inline_comments_for_kind!("book", messages, diff_lines, danger_comments, previous_violations[:message], danger_id: danger_id)
+        submit_inline_comments_for_kind!(nil, markdowns, diff_lines, danger_comments, [], danger_id: danger_id)
+
+        # submit removes from the array all comments that are still in force
+        # so we strike out all remaining ones
+        danger_comments.each do |comment|
+          violation = violations_from_table(comment[:body]).first
+          if !violation.nil? && violation.sticky
+            body = generate_inline_comment_body("white_check_mark", violation, danger_id: danger_id, resolved: true, template: "github")
+            client.update_pull_request_comment(ci_source.repo_slug, comment[:id], body)
+          else
+            # We remove non-sticky violations that have no replies
+            # Since there's no direct concept of a reply in GH, we simply consider
+            # the existance of non-danger comments in that line as replies
+            replies = non_danger_comments.select do |potential|
+              potential[:path] == comment[:path] &&
+                potential[:position] == comment[:position] &&
+                potential[:commit_id] == comment[:commit_id]
+            end
+
+            client.delete_pull_request_comment(ci_source.repo_slug, comment[:id]) if replies.empty?
+          end
+        end
+      end
+
+      def messages_are_equivalent(m1, m2)
+        blob_regexp = %r{blob/[0-9a-z]+/}
+        m1.file == m2.file && m1.line == m2.line &&
+          m1.message.sub(blob_regexp, "") == m2.message.sub(blob_regexp, "")
+      end
+
+      def submit_inline_comments_for_kind!(emoji, messages, diff_lines, danger_comments, previous_violations, danger_id: "danger")
+        head_ref = pr_json[:head][:sha]
+        previous_violations ||= []
+        is_markdown_content = emoji.nil?
+
+        submit_inline = proc do |m|
+          next false unless m.file && m.line
+
+          position = find_position_in_diff diff_lines, m
+
+          # Keep the change if it's line is not in the diff
+          next false if position.nil?
+
+          # Once we know we're gonna submit it, we format it
+          if is_markdown_content
+            body = generate_inline_markdown_body(m, danger_id: danger_id, template: "github")
+          else
+            # Hide the inline link behind a span
+            m = process_markdown(m, true)
+            body = generate_inline_comment_body(emoji, m, danger_id: danger_id, template: "github")
+            # A comment might be in previous_violations because only now it's part of the unified diff
+            # We remove from the array since it won't have a place in the table anymore
+            previous_violations.reject! { |v| messages_are_equivalent(v, m) }
+          end
+
+          matching_comments = danger_comments.select do |comment_data|
+            if comment_data[:path] == m.file && comment_data[:commit_id] == head_ref && comment_data[:position] == position
+              # Parse it to avoid problems with strikethrough
+              violation = violations_from_table(comment_data[:body]).first
+              if violation
+                messages_are_equivalent(violation, m)
+              else
+                comment_data[:body] == body
+              end
+            else
+              false
+            end
+          end
+
+          if matching_comments.empty?
+            client.create_pull_request_comment(ci_source.repo_slug, ci_source.pull_request_id,
+                                               body, head_ref, m.file, position)
+          else
+            # Remove the surviving comment so we don't strike it out
+            danger_comments.reject! { |c| matching_comments.include? c }
+
+            # Update the comment to remove the strikethrough if present
+            comment = matching_comments.first
+            client.update_pull_request_comment(ci_source.repo_slug, comment[:id], body)
+          end
+
+          # Remove this element from the array
+          next true
+        end
+
+        messages.reject!(&submit_inline)
+      end
+
+      def find_position_in_diff(diff_lines, message)
+        range_header_regexp = /@@ -([0-9]+),([0-9]+) \+(?<start>[0-9]+)(,(?<end>[0-9]+))? @@.*/
+        file_header_regexp = %r{ a/.*}
+
+        pattern = "+++ b/" + message.file + "\n"
+        file_start = diff_lines.index(pattern)
+
+        return nil if file_start.nil?
+
+        position = -1
+        file_line = nil
+
+        diff_lines.drop(file_start).each do |line|
+          match = line.match range_header_regexp
+
+          # file_line is set once we find the hunk the line is in
+          # we need to count how many lines in new file we have
+          # so we do it one by one ignoring the deleted lines
+          if !file_line.nil? && !line.start_with?("-")
+            break if file_line == message.line
+            file_line += 1
+          end
+
+          # We need to count how many diff lines are between us and
+          # the line we're looking for
+          position += 1
+
+          next unless match
+
+          # If we found the start of another file diff, we went too far
+          break if line.match file_header_regexp
+
+          range_start = match[:start].to_i
+          if match[:end]
+            range_end = match[:end].to_i + range_start
+          else
+            range_end = range_start
+          end
+
+          # We are past the line position, just abort
+          break if message.line < range_start
+          next unless message.line >= range_start && message.line <= range_end
+
+          file_line = range_start
+        end
+
+        position unless file_line.nil?
+      end
+
+      # See the tests for examples of data coming in looks like
+      def parse_message_from_row(row)
+        message_regexp = %r{(<(a |span data-)href="https://github.com/#{ci_source.repo_slug}/blob/[0-9a-z]+/(?<file>[^#]+)#L(?<line>[0-9]+)"(>[^<]*</a> - |/>))?(?<message>.*?)}im
+        match = message_regexp.match(row)
+
+        if match[:line]
+          line = match[:line].to_i
+        else
+          line = nil
+        end
+        Violation.new(row, true, match[:file], line)
+      end
+
+      def markdown_link_to_message(message, hide_link)
+        url = "https://github.com/#{ci_source.repo_slug}/blob/#{pr_json[:head][:sha]}/#{message.file}#L#{message.line}"
+
+        if hide_link
+          "<span data-href=\"#{url}\"/>"
+        else
+          "[#{message.file}#L#{message.line}](#{url}) - "
+        end
+      end
+
       # @return [String] The organisation name, is nil if it can't be detected
       def organisation
         matched = self.issue_json[:repository_url].match(%r{repos\/(.*)\/})
diff --git a/spec/fixtures/comment_with_file_link.html b/spec/fixtures/comment_with_file_link.html
new file mode 100644
index 0000000..b24de02
--- /dev/null
+++ b/spec/fixtures/comment_with_file_link.html
@@ -0,0 +1,14 @@
+<table>
+  <thead>
+    <tr>
+      <th width="50"></th>
+      <th width="100%">1 Warning</th>
+    </tr>
+  </thead>
+  <tbody>
+  <tr>
+    <td>:warning:</td>
+    <td data-sticky="true"><a href="https://github.com/artsy/eigen/blob/13c4dc8bb61d/.gitignore#L10">.gitignore:10</a> - some warning</td>
+  </tr>
+  </tbody>
+</table>
diff --git a/spec/fixtures/github_api/inline_comments.json b/spec/fixtures/github_api/inline_comments.json
new file mode 100644
index 0000000..96b79f5
--- /dev/null
+++ b/spec/fixtures/github_api/inline_comments.json
@@ -0,0 +1,587 @@
+[
+  {
+    "url": "https://api.github.com/repos/danger/danger/pulls/comments/73741079",
+    "id": 73741079,
+    "diff_hunk": "@@ -0,0 +1,22 @@\n+<%- @tables.each do |table| -%>\n+  <%- if table[:content].any? -%>\n+<table>\n+  <tbody>\n+    <%- table[:content].each do |violation| -%>\n+    <tr>\n+      <td>:<%= table[:emoji] %>:</td>\n+      <td data-sticky=\"<%= violation.sticky %>\"><%= \"<del>\" if table[:resolved] %><%= violation.message %><%= \"</del>\" if table[:resolved] %></td>\n+    </tr>\n+    <%- end -%>\n+  </tbody>\n+</table>\n+  <%- end -%>\n+<%- end -%>\n+\n+<%- @markdowns.each do |current| -%>\n+<%= current %>\n+<%# the previous line has to be aligned far to the left, otherwise markdown can break easily %>\n+<%- end -%>\n+<p align=\"right\" data-meta=\"generated_by_<%= @danger_id %>\">\n+  Generated by :no_entry_sign: <a href=\"http://danger.systems/\">Danger</a>\n+</p>",
+    "path": "lib/danger/comment_generators/github_inline.md.erb",
+    "position": null,
+    "original_position": 22,
+    "commit_id": "56d4fb4c2d11f36a70b41afe28c962873d16facc",
+    "original_commit_id": "ddc481cebb3250e28fee6019dbaf524019fa62a7",
+    "user": {
+      "login": "orta",
+      "id": 49038,
+      "avatar_url": "https://avatars.githubusercontent.com/u/49038?v=3",
+      "gravatar_id": "",
+      "url": "https://api.github.com/users/orta",
+      "html_url": "https://github.com/orta",
+      "followers_url": "https://api.github.com/users/orta/followers",
+      "following_url": "https://api.github.com/users/orta/following{/other_user}",
+      "gists_url": "https://api.github.com/users/orta/gists{/gist_id}",
+      "starred_url": "https://api.github.com/users/orta/starred{/owner}{/repo}",
+      "subscriptions_url": "https://api.github.com/users/orta/subscriptions",
+      "organizations_url": "https://api.github.com/users/orta/orgs",
+      "repos_url": "https://api.github.com/users/orta/repos",
+      "events_url": "https://api.github.com/users/orta/events{/privacy}",
+      "received_events_url": "https://api.github.com/users/orta/received_events",
+      "type": "User",
+      "site_admin": false
+    },
+    "body": "I wonder if this may be more annoying, I think we can live without the Danger advert for inline comments üëç ",
+    "created_at": "2016-08-05T18:43:15Z",
+    "updated_at": "2016-08-28T19:15:34Z",
+    "html_url": "https://github.com/danger/danger/pull/412#discussion_r73741079",
+    "pull_request_url": "https://api.github.com/repos/danger/danger/pulls/412",
+    "_links": {
+      "self": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/comments/73741079"
+      },
+      "html": {
+        "href": "https://github.com/danger/danger/pull/412#discussion_r73741079"
+      },
+      "pull_request": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/412"
+      }
+    }
+  },
+  {
+    "url": "https://api.github.com/repos/danger/danger/pulls/comments/73741698",
+    "id": 73741698,
+    "diff_hunk": "@@ -153,9 +176,148 @@ def delete_old_comments!(except: nil, danger_id: 'danger')\n         end\n       end\n \n+      def submit_inline_comments!(warnings: [], errors: [], messages: [], markdowns: [], previous_violations: [], danger_id: 'danger')\n+        filter = proc do |v|\n+          v.file && v.line\n+        end\n+\n+        # Avoid doing any fetchs if there's no inline comments\n+        return if (warnings + errors + messages).select(&filter).empty?",
+    "path": "lib/danger/request_source/github.rb",
+    "position": 48,
+    "original_position": 48,
+    "commit_id": "56d4fb4c2d11f36a70b41afe28c962873d16facc",
+    "original_commit_id": "ddc481cebb3250e28fee6019dbaf524019fa62a7",
+    "user": {
+      "login": "orta",
+      "id": 49038,
+      "avatar_url": "https://avatars.githubusercontent.com/u/49038?v=3",
+      "gravatar_id": "",
+      "url": "https://api.github.com/users/orta",
+      "html_url": "https://github.com/orta",
+      "followers_url": "https://api.github.com/users/orta/followers",
+      "following_url": "https://api.github.com/users/orta/following{/other_user}",
+      "gists_url": "https://api.github.com/users/orta/gists{/gist_id}",
+      "starred_url": "https://api.github.com/users/orta/starred{/owner}{/repo}",
+      "subscriptions_url": "https://api.github.com/users/orta/subscriptions",
+      "organizations_url": "https://api.github.com/users/orta/orgs",
+      "repos_url": "https://api.github.com/users/orta/repos",
+      "events_url": "https://api.github.com/users/orta/events{/privacy}",
+      "received_events_url": "https://api.github.com/users/orta/received_events",
+      "type": "User",
+      "site_admin": false
+    },
+    "body": "üëç good work",
+    "created_at": "2016-08-05T18:47:08Z",
+    "updated_at": "2016-08-28T19:15:34Z",
+    "html_url": "https://github.com/danger/danger/pull/412#discussion_r73741698",
+    "pull_request_url": "https://api.github.com/repos/danger/danger/pulls/412",
+    "_links": {
+      "self": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/comments/73741698"
+      },
+      "html": {
+        "href": "https://github.com/danger/danger/pull/412#discussion_r73741698"
+      },
+      "pull_request": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/412"
+      }
+    }
+  },
+  {
+    "url": "https://api.github.com/repos/danger/danger/pulls/comments/73741830",
+    "id": 73741830,
+    "diff_hunk": "@@ -0,0 +1,22 @@\n+<%- @tables.each do |table| -%>\n+  <%- if table[:content].any? -%>\n+<table>\n+  <tbody>\n+    <%- table[:content].each do |violation| -%>\n+    <tr>\n+      <td>:<%= table[:emoji] %>:</td>\n+      <td data-sticky=\"<%= violation.sticky %>\"><%= \"<del>\" if table[:resolved] %><%= violation.message %><%= \"</del>\" if table[:resolved] %></td>\n+    </tr>\n+    <%- end -%>\n+  </tbody>\n+</table>\n+  <%- end -%>\n+<%- end -%>\n+\n+<%- @markdowns.each do |current| -%>\n+<%= current %>\n+<%# the previous line has to be aligned far to the left, otherwise markdown can break easily %>\n+<%- end -%>\n+<p align=\"right\" data-meta=\"generated_by_<%= @danger_id %>\">\n+  Generated by :no_entry_sign: <a href=\"http://danger.systems/\">Danger</a>\n+</p>",
+    "path": "lib/danger/comment_generators/github_inline.md.erb",
+    "position": null,
+    "original_position": 22,
+    "commit_id": "56d4fb4c2d11f36a70b41afe28c962873d16facc",
+    "original_commit_id": "ddc481cebb3250e28fee6019dbaf524019fa62a7",
+    "user": {
+      "login": "orta",
+      "id": 49038,
+      "avatar_url": "https://avatars.githubusercontent.com/u/49038?v=3",
+      "gravatar_id": "",
+      "url": "https://api.github.com/users/orta",
+      "html_url": "https://github.com/orta",
+      "followers_url": "https://api.github.com/users/orta/followers",
+      "following_url": "https://api.github.com/users/orta/following{/other_user}",
+      "gists_url": "https://api.github.com/users/orta/gists{/gist_id}",
+      "starred_url": "https://api.github.com/users/orta/starred{/owner}{/repo}",
+      "subscriptions_url": "https://api.github.com/users/orta/subscriptions",
+      "organizations_url": "https://api.github.com/users/orta/orgs",
+      "repos_url": "https://api.github.com/users/orta/repos",
+      "events_url": "https://api.github.com/users/orta/events{/privacy}",
+      "received_events_url": "https://api.github.com/users/orta/received_events",
+      "type": "User",
+      "site_admin": false
+    },
+    "body": "though the `data-meta=\"generated_by_<%= @danger_id %>\"` would need to stay somewhow",
+    "created_at": "2016-08-05T18:47:58Z",
+    "updated_at": "2016-08-28T19:15:34Z",
+    "html_url": "https://github.com/danger/danger/pull/412#discussion_r73741830",
+    "pull_request_url": "https://api.github.com/repos/danger/danger/pulls/412",
+    "_links": {
+      "self": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/comments/73741830"
+      },
+      "html": {
+        "href": "https://github.com/danger/danger/pull/412#discussion_r73741830"
+      },
+      "pull_request": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/412"
+      }
+    }
+  },
+  {
+    "url": "https://api.github.com/repos/danger/danger/pulls/comments/73742253",
+    "id": 73742253,
+    "diff_hunk": "@@ -153,9 +176,148 @@ def delete_old_comments!(except: nil, danger_id: 'danger')\n         end\n       end\n \n+      def submit_inline_comments!(warnings: [], errors: [], messages: [], markdowns: [], previous_violations: [], danger_id: 'danger')\n+        filter = proc do |v|\n+          v.file && v.line\n+        end\n+\n+        # Avoid doing any fetchs if there's no inline comments\n+        return if (warnings + errors + messages).select(&filter).empty?\n+\n+        diff_lines = self.pr_diff.lines\n+        pr_comments = client.pull_request_comments(ci_source.repo_slug, ci_source.pull_request_id)\n+        danger_comments = pr_comments.select { |comment| comment[:body].include?(\"generated_by_#{danger_id}\") }\n+\n+        submit_inline_comments_for_kind!('warning', warnings, diff_lines, danger_comments, previous_violations[:warning], danger_id: danger_id)\n+        submit_inline_comments_for_kind!('no_entry_sign', errors, diff_lines, danger_comments, previous_violations[:error], danger_id: danger_id)\n+        submit_inline_comments_for_kind!('book', messages, diff_lines, danger_comments, previous_violations[:message], danger_id: danger_id)\n+        submit_inline_comments_for_kind!(nil, markdowns, diff_lines, danger_comments, [], danger_id: danger_id)\n+\n+        # submit removes from the array all comments that are still in force\n+        # so we strike out all remaining ones\n+        danger_comments.each do |comment|\n+          violation = violations_from_table(comment[:body]).first\n+          next if violation.nil?\n+\n+          # TODO: Check that this violation isn't now out of the diff (case of a force push)\n+\n+          body = generate_inline_comment_body('white_check_mark', violation, danger_id: danger_id, resolved: true, template: \"github\")\n+          client.update_pull_request_comment(ci_source.repo_slug, comment[:id], body)\n+        end\n+      end\n+\n+      def messages_are_equivalent(m1, m2)\n+        blob_regexp = %r{blob/[0-9a-z]+/}\n+        m1.file == m2.file && m1.line == m2.line &&\n+          m1.message.sub(blob_regexp, \"\") == m2.message.sub(blob_regexp, \"\")\n+      end\n+\n+      def submit_inline_comments_for_kind!(emoji, messages, diff_lines, danger_comments, previous_violations, danger_id: \"danger\")\n+        head_ref = pr_json[:head][:sha]\n+        previous_violations ||= []\n+        submit_inline = proc do |m|\n+          next false unless m.file && m.line\n+\n+          position = find_position_in_diff diff_lines, m\n+\n+          # Keep the change if it's line is not in the diff\n+          next false if position.nil?\n+\n+          # Once we know we're gonna submit it, we format it\n+          if emoji.nil?",
+    "path": "lib/danger/request_source/github.rb",
+    "position": null,
+    "original_position": 90,
+    "commit_id": "56d4fb4c2d11f36a70b41afe28c962873d16facc",
+    "original_commit_id": "ddc481cebb3250e28fee6019dbaf524019fa62a7",
+    "user": {
+      "login": "orta",
+      "id": 49038,
+      "avatar_url": "https://avatars.githubusercontent.com/u/49038?v=3",
+      "gravatar_id": "",
+      "url": "https://api.github.com/users/orta",
+      "html_url": "https://github.com/orta",
+      "followers_url": "https://api.github.com/users/orta/followers",
+      "following_url": "https://api.github.com/users/orta/following{/other_user}",
+      "gists_url": "https://api.github.com/users/orta/gists{/gist_id}",
+      "starred_url": "https://api.github.com/users/orta/starred{/owner}{/repo}",
+      "subscriptions_url": "https://api.github.com/users/orta/subscriptions",
+      "organizations_url": "https://api.github.com/users/orta/orgs",
+      "repos_url": "https://api.github.com/users/orta/repos",
+      "events_url": "https://api.github.com/users/orta/events{/privacy}",
+      "received_events_url": "https://api.github.com/users/orta/received_events",
+      "type": "User",
+      "site_admin": false
+    },
+    "body": "any chance you can turn this into a variable? `is_markdown_content = emoji.nil?` maybe? wasn't intuitive at first glance",
+    "created_at": "2016-08-05T18:50:53Z",
+    "updated_at": "2016-08-28T19:15:34Z",
+    "html_url": "https://github.com/danger/danger/pull/412#discussion_r73742253",
+    "pull_request_url": "https://api.github.com/repos/danger/danger/pulls/412",
+    "_links": {
+      "self": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/comments/73742253"
+      },
+      "html": {
+        "href": "https://github.com/danger/danger/pull/412#discussion_r73742253"
+      },
+      "pull_request": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/412"
+      }
+    }
+  },
+  {
+    "url": "https://api.github.com/repos/danger/danger/pulls/comments/73742539",
+    "id": 73742539,
+    "diff_hunk": "@@ -153,9 +176,148 @@ def delete_old_comments!(except: nil, danger_id: 'danger')\n         end\n       end\n \n+      def submit_inline_comments!(warnings: [], errors: [], messages: [], markdowns: [], previous_violations: [], danger_id: 'danger')\n+        filter = proc do |v|\n+          v.file && v.line\n+        end\n+\n+        # Avoid doing any fetchs if there's no inline comments\n+        return if (warnings + errors + messages).select(&filter).empty?\n+\n+        diff_lines = self.pr_diff.lines\n+        pr_comments = client.pull_request_comments(ci_source.repo_slug, ci_source.pull_request_id)\n+        danger_comments = pr_comments.select { |comment| comment[:body].include?(\"generated_by_#{danger_id}\") }\n+\n+        submit_inline_comments_for_kind!('warning', warnings, diff_lines, danger_comments, previous_violations[:warning], danger_id: danger_id)\n+        submit_inline_comments_for_kind!('no_entry_sign', errors, diff_lines, danger_comments, previous_violations[:error], danger_id: danger_id)\n+        submit_inline_comments_for_kind!('book', messages, diff_lines, danger_comments, previous_violations[:message], danger_id: danger_id)\n+        submit_inline_comments_for_kind!(nil, markdowns, diff_lines, danger_comments, [], danger_id: danger_id)\n+\n+        # submit removes from the array all comments that are still in force\n+        # so we strike out all remaining ones\n+        danger_comments.each do |comment|\n+          violation = violations_from_table(comment[:body]).first\n+          next if violation.nil?\n+\n+          # TODO: Check that this violation isn't now out of the diff (case of a force push)\n+\n+          body = generate_inline_comment_body('white_check_mark', violation, danger_id: danger_id, resolved: true, template: \"github\")\n+          client.update_pull_request_comment(ci_source.repo_slug, comment[:id], body)\n+        end\n+      end\n+\n+      def messages_are_equivalent(m1, m2)\n+        blob_regexp = %r{blob/[0-9a-z]+/}\n+        m1.file == m2.file && m1.line == m2.line &&\n+          m1.message.sub(blob_regexp, \"\") == m2.message.sub(blob_regexp, \"\")\n+      end\n+\n+      def submit_inline_comments_for_kind!(emoji, messages, diff_lines, danger_comments, previous_violations, danger_id: \"danger\")\n+        head_ref = pr_json[:head][:sha]\n+        previous_violations ||= []\n+        submit_inline = proc do |m|\n+          next false unless m.file && m.line\n+\n+          position = find_position_in_diff diff_lines, m\n+\n+          # Keep the change if it's line is not in the diff\n+          next false if position.nil?\n+\n+          # Once we know we're gonna submit it, we format it\n+          if emoji.nil?\n+            body = generate_inline_markdown_body(m, danger_id: danger_id, template: \"github\")\n+          else\n+            m = process_markdown(m)\n+            body = generate_inline_comment_body(emoji, m, danger_id: danger_id, template: \"github\")\n+            # A comment might be in previous_violations because only now it's part of the unified diff\n+            # We remove from the array since it won't have a place in the table anymore\n+            previous_violations.reject! { |v| messages_are_equivalent(v, m) }\n+          end\n+\n+          matching_comments = danger_comments.select do |i|",
+    "path": "lib/danger/request_source/github.rb",
+    "position": null,
+    "original_position": 100,
+    "commit_id": "56d4fb4c2d11f36a70b41afe28c962873d16facc",
+    "original_commit_id": "ddc481cebb3250e28fee6019dbaf524019fa62a7",
+    "user": {
+      "login": "orta",
+      "id": 49038,
+      "avatar_url": "https://avatars.githubusercontent.com/u/49038?v=3",
+      "gravatar_id": "",
+      "url": "https://api.github.com/users/orta",
+      "html_url": "https://github.com/orta",
+      "followers_url": "https://api.github.com/users/orta/followers",
+      "following_url": "https://api.github.com/users/orta/following{/other_user}",
+      "gists_url": "https://api.github.com/users/orta/gists{/gist_id}",
+      "starred_url": "https://api.github.com/users/orta/starred{/owner}{/repo}",
+      "subscriptions_url": "https://api.github.com/users/orta/subscriptions",
+      "organizations_url": "https://api.github.com/users/orta/orgs",
+      "repos_url": "https://api.github.com/users/orta/repos",
+      "events_url": "https://api.github.com/users/orta/events{/privacy}",
+      "received_events_url": "https://api.github.com/users/orta/received_events",
+      "type": "User",
+      "site_admin": false
+    },
+    "body": "`i` could maybe be something like `data`? ",
+    "created_at": "2016-08-05T18:52:40Z",
+    "updated_at": "2016-08-28T19:15:34Z",
+    "html_url": "https://github.com/danger/danger/pull/412#discussion_r73742539",
+    "pull_request_url": "https://api.github.com/repos/danger/danger/pulls/412",
+    "_links": {
+      "self": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/comments/73742539"
+      },
+      "html": {
+        "href": "https://github.com/danger/danger/pull/412#discussion_r73742539"
+      },
+      "pull_request": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/412"
+      }
+    }
+  },
+  {
+    "url": "https://api.github.com/repos/danger/danger/pulls/comments/73791212",
+    "id": 73791212,
+    "diff_hunk": "@@ -1,24 +1,18 @@\n require \"kramdown\"\n+require \"danger/helpers/comments_parsing_helper\"\n \n module Danger\n   module Helpers\n     module CommentsHelper\n+      # This might be a bit weird, but table_kind_from_title is a shared dependency for\n+      # parsing and generating. And rubocop was adamnt about file size so...",
+    "path": "lib/danger/helpers/comments_helper.rb",
+    "position": null,
+    "original_position": 8,
+    "commit_id": "56d4fb4c2d11f36a70b41afe28c962873d16facc",
+    "original_commit_id": "179ab2ca713f87e1388c81c12155f07c4be205ec",
+    "user": {
+      "login": "orta",
+      "id": 49038,
+      "avatar_url": "https://avatars.githubusercontent.com/u/49038?v=3",
+      "gravatar_id": "",
+      "url": "https://api.github.com/users/orta",
+      "html_url": "https://github.com/orta",
+      "followers_url": "https://api.github.com/users/orta/followers",
+      "following_url": "https://api.github.com/users/orta/following{/other_user}",
+      "gists_url": "https://api.github.com/users/orta/gists{/gist_id}",
+      "starred_url": "https://api.github.com/users/orta/starred{/owner}{/repo}",
+      "subscriptions_url": "https://api.github.com/users/orta/subscriptions",
+      "organizations_url": "https://api.github.com/users/orta/orgs",
+      "repos_url": "https://api.github.com/users/orta/repos",
+      "events_url": "https://api.github.com/users/orta/events{/privacy}",
+      "received_events_url": "https://api.github.com/users/orta/received_events",
+      "type": "User",
+      "site_admin": false
+    },
+    "body": "heh - plus, there's a typo in `adamant` üëç ",
+    "created_at": "2016-08-06T20:00:44Z",
+    "updated_at": "2016-08-28T19:15:34Z",
+    "html_url": "https://github.com/danger/danger/pull/412#discussion_r73791212",
+    "pull_request_url": "https://api.github.com/repos/danger/danger/pulls/412",
+    "_links": {
+      "self": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/comments/73791212"
+      },
+      "html": {
+        "href": "https://github.com/danger/danger/pull/412#discussion_r73791212"
+      },
+      "pull_request": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/412"
+      }
+    }
+  },
+  {
+    "url": "https://api.github.com/repos/danger/danger/pulls/comments/75586340",
+    "id": 75586340,
+    "diff_hunk": "@@ -153,9 +176,148 @@ def delete_old_comments!(except: nil, danger_id: 'danger')\n         end\n       end\n \n+      def submit_inline_comments!(warnings: [], errors: [], messages: [], markdowns: [], previous_violations: [], danger_id: 'danger')\n+        filter = proc do |v|\n+          v.file && v.line\n+        end\n+\n+        # Avoid doing any fetchs if there's no inline comments\n+        return if (warnings + errors + messages).select(&filter).empty?",
+    "path": "lib/danger/request_source/github.rb",
+    "position": 48,
+    "original_position": 48,
+    "commit_id": "56d4fb4c2d11f36a70b41afe28c962873d16facc",
+    "original_commit_id": "ddc481cebb3250e28fee6019dbaf524019fa62a7",
+    "user": {
+      "login": "champo",
+      "id": 202728,
+      "avatar_url": "https://avatars.githubusercontent.com/u/202728?v=3",
+      "gravatar_id": "",
+      "url": "https://api.github.com/users/champo",
+      "html_url": "https://github.com/champo",
+      "followers_url": "https://api.github.com/users/champo/followers",
+      "following_url": "https://api.github.com/users/champo/following{/other_user}",
+      "gists_url": "https://api.github.com/users/champo/gists{/gist_id}",
+      "starred_url": "https://api.github.com/users/champo/starred{/owner}{/repo}",
+      "subscriptions_url": "https://api.github.com/users/champo/subscriptions",
+      "organizations_url": "https://api.github.com/users/champo/orgs",
+      "repos_url": "https://api.github.com/users/champo/repos",
+      "events_url": "https://api.github.com/users/champo/events{/privacy}",
+      "received_events_url": "https://api.github.com/users/champo/received_events",
+      "type": "User",
+      "site_admin": false
+    },
+    "body": "I've been thinking about this line, and with the non-sticky comments it's no longer effective. This might end up leaving resolved violations without updating.",
+    "created_at": "2016-08-20T23:24:32Z",
+    "updated_at": "2016-08-28T19:15:34Z",
+    "html_url": "https://github.com/danger/danger/pull/412#discussion_r75586340",
+    "pull_request_url": "https://api.github.com/repos/danger/danger/pulls/412",
+    "_links": {
+      "self": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/comments/75586340"
+      },
+      "html": {
+        "href": "https://github.com/danger/danger/pull/412#discussion_r75586340"
+      },
+      "pull_request": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/412"
+      }
+    }
+  },
+  {
+    "url": "https://api.github.com/repos/danger/danger/pulls/comments/75586349",
+    "id": 75586349,
+    "diff_hunk": "@@ -153,9 +176,148 @@ def delete_old_comments!(except: nil, danger_id: 'danger')\n         end\n       end\n \n+      def submit_inline_comments!(warnings: [], errors: [], messages: [], markdowns: [], previous_violations: [], danger_id: 'danger')\n+        filter = proc do |v|\n+          v.file && v.line\n+        end\n+\n+        # Avoid doing any fetchs if there's no inline comments\n+        return if (warnings + errors + messages).select(&filter).empty?",
+    "path": "lib/danger/request_source/github.rb",
+    "position": 48,
+    "original_position": 48,
+    "commit_id": "56d4fb4c2d11f36a70b41afe28c962873d16facc",
+    "original_commit_id": "ddc481cebb3250e28fee6019dbaf524019fa62a7",
+    "user": {
+      "login": "orta",
+      "id": 49038,
+      "avatar_url": "https://avatars.githubusercontent.com/u/49038?v=3",
+      "gravatar_id": "",
+      "url": "https://api.github.com/users/orta",
+      "html_url": "https://github.com/orta",
+      "followers_url": "https://api.github.com/users/orta/followers",
+      "following_url": "https://api.github.com/users/orta/following{/other_user}",
+      "gists_url": "https://api.github.com/users/orta/gists{/gist_id}",
+      "starred_url": "https://api.github.com/users/orta/starred{/owner}{/repo}",
+      "subscriptions_url": "https://api.github.com/users/orta/subscriptions",
+      "organizations_url": "https://api.github.com/users/orta/orgs",
+      "repos_url": "https://api.github.com/users/orta/repos",
+      "events_url": "https://api.github.com/users/orta/events{/privacy}",
+      "received_events_url": "https://api.github.com/users/orta/received_events",
+      "type": "User",
+      "site_admin": false
+    },
+    "body": "Ah - yeah, that could make sense",
+    "created_at": "2016-08-20T23:25:35Z",
+    "updated_at": "2016-08-28T19:15:34Z",
+    "html_url": "https://github.com/danger/danger/pull/412#discussion_r75586349",
+    "pull_request_url": "https://api.github.com/repos/danger/danger/pulls/412",
+    "_links": {
+      "self": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/comments/75586349"
+      },
+      "html": {
+        "href": "https://github.com/danger/danger/pull/412#discussion_r75586349"
+      },
+      "pull_request": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/412"
+      }
+    }
+  },
+  {
+    "url": "https://api.github.com/repos/danger/danger/pulls/comments/76535362",
+    "id": 76535362,
+    "diff_hunk": "@@ -1,5 +1,6 @@\n ## Master\n \n+* add `file` and `line` optional parameters to methods on the messaging plugin",
+    "path": "CHANGELOG.md",
+    "position": 3,
+    "original_position": 3,
+    "commit_id": "56d4fb4c2d11f36a70b41afe28c962873d16facc",
+    "original_commit_id": "5e1147793672f37ed957cc17f46b1eb588355afa",
+    "user": {
+      "login": "DangerCI",
+      "id": 17546894,
+      "avatar_url": "https://avatars.githubusercontent.com/u/17546894?v=3",
+      "gravatar_id": "",
+      "url": "https://api.github.com/users/DangerCI",
+      "html_url": "https://github.com/DangerCI",
+      "followers_url": "https://api.github.com/users/DangerCI/followers",
+      "following_url": "https://api.github.com/users/DangerCI/following{/other_user}",
+      "gists_url": "https://api.github.com/users/DangerCI/gists{/gist_id}",
+      "starred_url": "https://api.github.com/users/DangerCI/starred{/owner}{/repo}",
+      "subscriptions_url": "https://api.github.com/users/DangerCI/subscriptions",
+      "organizations_url": "https://api.github.com/users/DangerCI/orgs",
+      "repos_url": "https://api.github.com/users/DangerCI/repos",
+      "events_url": "https://api.github.com/users/DangerCI/events{/privacy}",
+      "received_events_url": "https://api.github.com/users/DangerCI/received_events",
+      "type": "User",
+      "site_admin": false
+    },
+    "body": "<table data-meta=\"generated_by_danger\">\r\n  <tbody>\r\n    <tr>\r\n      <td>:white_check_mark:</td>\r\n      <td ><del><a href=\"https://github.com/danger/danger/blob/5e1147793672f37ed957cc17f46b1eb588355afa/CHANGELOG.md#L3\" style=\"display:none\">CHANGELOG.md#L3</a> - Testing inline docs</del></td>\r\n</tr>\r\n<tr>\r\n      <td>:white_check_mark:</td>\r\n      <td ><span data-href=\"https://github.com/artsy/eigen/blob/8e5d0bab431839a7046b2f7d5cd5ccb91677fe23/CHANGELOG.md#L1\"/>\r\nTesting inline docs</td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n\r\n\r\n",
+    "created_at": "2016-08-28T16:47:56Z",
+    "updated_at": "2016-08-28T19:15:34Z",
+    "html_url": "https://github.com/danger/danger/pull/412#discussion_r76535362",
+    "pull_request_url": "https://api.github.com/repos/danger/danger/pulls/412",
+    "_links": {
+      "self": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/comments/76535362"
+      },
+      "html": {
+        "href": "https://github.com/danger/danger/pull/412#discussion_r76535362"
+      },
+      "pull_request": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/412"
+      }
+    }
+  },
+  {
+    "url": "https://api.github.com/repos/danger/danger/pulls/comments/76535491",
+    "id": 76535491,
+    "diff_hunk": "@@ -1,5 +1,6 @@\n ## Master\n \n+* add `file` and `line` optional parameters to methods on the messaging plugin",
+    "path": "CHANGELOG.md",
+    "position": 3,
+    "original_position": 3,
+    "commit_id": "56d4fb4c2d11f36a70b41afe28c962873d16facc",
+    "original_commit_id": "5e1147793672f37ed957cc17f46b1eb588355afa",
+    "user": {
+      "login": "orta",
+      "id": 49038,
+      "avatar_url": "https://avatars.githubusercontent.com/u/49038?v=3",
+      "gravatar_id": "",
+      "url": "https://api.github.com/users/orta",
+      "html_url": "https://github.com/orta",
+      "followers_url": "https://api.github.com/users/orta/followers",
+      "following_url": "https://api.github.com/users/orta/following{/other_user}",
+      "gists_url": "https://api.github.com/users/orta/gists{/gist_id}",
+      "starred_url": "https://api.github.com/users/orta/starred{/owner}{/repo}",
+      "subscriptions_url": "https://api.github.com/users/orta/subscriptions",
+      "organizations_url": "https://api.github.com/users/orta/orgs",
+      "repos_url": "https://api.github.com/users/orta/repos",
+      "events_url": "https://api.github.com/users/orta/events{/privacy}",
+      "received_events_url": "https://api.github.com/users/orta/received_events",
+      "type": "User",
+      "site_admin": false
+    },
+    "body": "<span data=\"thingy\"></span>If I comment on this, it should not go away, if I recall ",
+    "created_at": "2016-08-28T16:57:51Z",
+    "updated_at": "2016-08-28T19:15:34Z",
+    "html_url": "https://github.com/danger/danger/pull/412#discussion_r76535491",
+    "pull_request_url": "https://api.github.com/repos/danger/danger/pulls/412",
+    "_links": {
+      "self": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/comments/76535491"
+      },
+      "html": {
+        "href": "https://github.com/danger/danger/pull/412#discussion_r76535491"
+      },
+      "pull_request": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/412"
+      }
+    }
+  },
+  {
+    "url": "https://api.github.com/repos/danger/danger/pulls/comments/76537315",
+    "id": 76537315,
+    "diff_hunk": "@@ -1,5 +1,6 @@\n ## Master",
+    "path": "CHANGELOG.md",
+    "position": 1,
+    "original_position": 1,
+    "commit_id": "56d4fb4c2d11f36a70b41afe28c962873d16facc",
+    "original_commit_id": "07c97dc05bbd55bb8ea90f6f2266f4712270803c",
+    "user": {
+      "login": "DangerCI",
+      "id": 17546894,
+      "avatar_url": "https://avatars.githubusercontent.com/u/17546894?v=3",
+      "gravatar_id": "",
+      "url": "https://api.github.com/users/DangerCI",
+      "html_url": "https://github.com/DangerCI",
+      "followers_url": "https://api.github.com/users/DangerCI/followers",
+      "following_url": "https://api.github.com/users/DangerCI/following{/other_user}",
+      "gists_url": "https://api.github.com/users/DangerCI/gists{/gist_id}",
+      "starred_url": "https://api.github.com/users/DangerCI/starred{/owner}{/repo}",
+      "subscriptions_url": "https://api.github.com/users/DangerCI/subscriptions",
+      "organizations_url": "https://api.github.com/users/DangerCI/orgs",
+      "repos_url": "https://api.github.com/users/DangerCI/repos",
+      "events_url": "https://api.github.com/users/DangerCI/events{/privacy}",
+      "received_events_url": "https://api.github.com/users/DangerCI/received_events",
+      "type": "User",
+      "site_admin": false
+    },
+    "body": "<table data-meta=\"generated_by_danger\">\n  <tbody>\n    <tr>\n      <td>:warning:</td>\n      <td width=\"100%\" data-sticky=\"false\"><span data-href=\"https://github.com/danger/danger/blob/07c97dc05bbd55bb8ea90f6f2266f4712270803c/CHANGELOG.md#L1\"></span>Testing inline docs</td>\n    </tr>\n  </tbody>\n</table>\n\n\n\n",
+    "created_at": "2016-08-28T19:06:37Z",
+    "updated_at": "2016-08-28T19:15:34Z",
+    "html_url": "https://github.com/danger/danger/pull/412#discussion_r76537315",
+    "pull_request_url": "https://api.github.com/repos/danger/danger/pulls/412",
+    "_links": {
+      "self": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/comments/76537315"
+      },
+      "html": {
+        "href": "https://github.com/danger/danger/pull/412#discussion_r76537315"
+      },
+      "pull_request": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/412"
+      }
+    }
+  },
+  {
+    "url": "https://api.github.com/repos/danger/danger/pulls/comments/76537316",
+    "id": 76537316,
+    "diff_hunk": "@@ -1,5 +1,6 @@\n ## Master\n \n+* add `file` and `line` optional parameters to methods on the messaging plugin\n * Show appropriate error message when GitHub repo was moved - KrauseFx",
+    "path": "CHANGELOG.md",
+    "position": 4,
+    "original_position": 4,
+    "commit_id": "56d4fb4c2d11f36a70b41afe28c962873d16facc",
+    "original_commit_id": "07c97dc05bbd55bb8ea90f6f2266f4712270803c",
+    "user": {
+      "login": "DangerCI",
+      "id": 17546894,
+      "avatar_url": "https://avatars.githubusercontent.com/u/17546894?v=3",
+      "gravatar_id": "",
+      "url": "https://api.github.com/users/DangerCI",
+      "html_url": "https://github.com/DangerCI",
+      "followers_url": "https://api.github.com/users/DangerCI/followers",
+      "following_url": "https://api.github.com/users/DangerCI/following{/other_user}",
+      "gists_url": "https://api.github.com/users/DangerCI/gists{/gist_id}",
+      "starred_url": "https://api.github.com/users/DangerCI/starred{/owner}{/repo}",
+      "subscriptions_url": "https://api.github.com/users/DangerCI/subscriptions",
+      "organizations_url": "https://api.github.com/users/DangerCI/orgs",
+      "repos_url": "https://api.github.com/users/DangerCI/repos",
+      "events_url": "https://api.github.com/users/DangerCI/events{/privacy}",
+      "received_events_url": "https://api.github.com/users/DangerCI/received_events",
+      "type": "User",
+      "site_admin": false
+    },
+    "body": "<table data-meta=\"generated_by_danger\">\n  <tbody>\n    <tr>\n      <td>:book:</td>\n      <td width=\"100%\" data-sticky=\"true\"><span data-href=\"https://github.com/danger/danger/blob/07c97dc05bbd55bb8ea90f6f2266f4712270803c/CHANGELOG.md#L4\"></span>Sure thing</td>\n    </tr>\n  </tbody>\n</table>\n\n\n\n",
+    "created_at": "2016-08-28T19:06:37Z",
+    "updated_at": "2016-08-28T19:15:34Z",
+    "html_url": "https://github.com/danger/danger/pull/412#discussion_r76537316",
+    "pull_request_url": "https://api.github.com/repos/danger/danger/pulls/412",
+    "_links": {
+      "self": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/comments/76537316"
+      },
+      "html": {
+        "href": "https://github.com/danger/danger/pull/412#discussion_r76537316"
+      },
+      "pull_request": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/412"
+      }
+    }
+  },
+  {
+    "url": "https://api.github.com/repos/danger/danger/pulls/comments/76537524",
+    "id": 76537524,
+    "diff_hunk": "@@ -0,0 +1,61 @@\n+{",
+    "path": ".vscode/launch.json",
+    "position": 1,
+    "original_position": 1,
+    "commit_id": "56d4fb4c2d11f36a70b41afe28c962873d16facc",
+    "original_commit_id": "56d4fb4c2d11f36a70b41afe28c962873d16facc",
+    "user": {
+      "login": "orta",
+      "id": 49038,
+      "avatar_url": "https://avatars.githubusercontent.com/u/49038?v=3",
+      "gravatar_id": "",
+      "url": "https://api.github.com/users/orta",
+      "html_url": "https://github.com/orta",
+      "followers_url": "https://api.github.com/users/orta/followers",
+      "following_url": "https://api.github.com/users/orta/following{/other_user}",
+      "gists_url": "https://api.github.com/users/orta/gists{/gist_id}",
+      "starred_url": "https://api.github.com/users/orta/starred{/owner}{/repo}",
+      "subscriptions_url": "https://api.github.com/users/orta/subscriptions",
+      "organizations_url": "https://api.github.com/users/orta/orgs",
+      "repos_url": "https://api.github.com/users/orta/repos",
+      "events_url": "https://api.github.com/users/orta/events{/privacy}",
+      "received_events_url": "https://api.github.com/users/orta/received_events",
+      "type": "User",
+      "site_admin": false
+    },
+    "body": "I was planning on including this at some point anyway",
+    "created_at": "2016-08-28T19:18:06Z",
+    "updated_at": "2016-08-28T19:18:06Z",
+    "html_url": "https://github.com/danger/danger/pull/412#discussion_r76537524",
+    "pull_request_url": "https://api.github.com/repos/danger/danger/pulls/412",
+    "_links": {
+      "self": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/comments/76537524"
+      },
+      "html": {
+        "href": "https://github.com/danger/danger/pull/412#discussion_r76537524"
+      },
+      "pull_request": {
+        "href": "https://api.github.com/repos/danger/danger/pulls/412"
+      }
+    }
+  }
+]
diff --git a/spec/lib/danger/danger_core/dangerfile_spec.rb b/spec/lib/danger/danger_core/dangerfile_spec.rb
index 50bd0c2..3d6e01f 100644
--- a/spec/lib/danger/danger_core/dangerfile_spec.rb
+++ b/spec/lib/danger/danger_core/dangerfile_spec.rb
@@ -60,9 +60,9 @@
 
       dm.parse Pathname.new(""), code
 
-      expect(dm).to receive(:print_list).with("Errors:".red, ["Another error", "An error"])
-      expect(dm).to receive(:print_list).with("Warnings:".yellow, ["Another warning", "A warning"])
-      expect(dm).to receive(:print_list).with("Messages:", ["A message"])
+      expect(dm).to receive(:print_list).with("Errors:".red, violations(["Another error", "An error"], sticky: true))
+      expect(dm).to receive(:print_list).with("Warnings:".yellow, violations(["Another warning", "A warning"], sticky: true))
+      expect(dm).to receive(:print_list).with("Messages:", violations(["A message"], sticky: true))
 
       dm.print_results
     end
diff --git a/spec/lib/danger/helpers/comments_helper_spec.rb b/spec/lib/danger/helpers/comments_helper_spec.rb
index d267975..dfb84bf 100644
--- a/spec/lib/danger/helpers/comments_helper_spec.rb
+++ b/spec/lib/danger/helpers/comments_helper_spec.rb
@@ -1,6 +1,6 @@
 # coding: utf-8
 require "danger/helpers/comments_helper"
-require "danger/danger_core/violation"
+require "danger/danger_core/messages/violation"
 
 SINGLE_TABLE_COMMENT = <<-EOS.freeze
   Other comment content
@@ -24,9 +24,7 @@
     <td>
       <g-emoji alias="no_entry_sign" fallback-src="https://example.com/1f6ab.png">üö´</g-emoji
     </td>
-    <td data-sticky="true"><p>Please include a CHANGELOG entry.
-    You can find it at
-    <a href="https://github.com/danger/danger/blob/master/CHANGELOG.md">CHANGELOG.md</a>.</p>
+    <td data-sticky="true"><p>Please include a CHANGELOG entry. You can find it at <a href="https://github.com/danger/danger/blob/master/CHANGELOG.md">CHANGELOG.md</a>.</p>
     </td></tr></tbody>
   </table>
   <table>
@@ -113,7 +111,9 @@ class Dummy
       violations = dummy.violations_from_table(SINGLE_TABLE_COMMENT)
 
       expect(violations.size).to be(1)
-      expect(violations.first).to eq("<p>Please include a CHANGELOG entry. You can find it at <a href=\"https://github.com/danger/danger/blob/master/CHANGELOG.md\">CHANGELOG.md</a>.</p>")
+      expect(violations.first).to eq(
+        violation("<p>Please include a CHANGELOG entry. You can find it at <a href=\"https://github.com/danger/danger/blob/master/CHANGELOG.md\">CHANGELOG.md</a>.</p>", sticky: true)
+      )
     end
   end
 
@@ -125,8 +125,10 @@ class Dummy
       expect(violations[:warning].size).to be(1)
       expect(violations[:message]).to be_nil
 
-      expect(violations[:error][0]).to include("Please include a CHANGELOG")
-      expect(violations[:warning][0]).to include("External contributor has edited")
+      expect(violations[:error][0]).to eq(
+        violation("<p>Please include a CHANGELOG entry. You can find it at <a href=\"https://github.com/danger/danger/blob/master/CHANGELOG.md\">CHANGELOG.md</a>.</p>", sticky: true)
+      )
+      expect(violations[:warning][0]).to eq(violation("<p>External contributor has edited the Gemspec</p>", sticky: true))
     end
 
     it "handles data-danger-table to identify danger tables" do
@@ -136,14 +138,14 @@ class Dummy
       expect(violations[:warning]).to be_nil
       expect(violations[:message]).to be_nil
 
-      expect(violations[:error][0]).to include("Please include a CHANGELOG")
+      expect(violations[:error].first.message).to include("Please include a CHANGELOG")
     end
   end
 
   describe "#table" do
-    let(:violation_1) { Danger::Violation.new("**Violation 1**", false) }
+    let(:violation_1) { violation("**Violation 1**") }
     let(:violation_2) do
-      Danger::Violation.new("A [link](https://example.com)", true)
+      violation("A [link](https://example.com)", sticky: true)
     end
 
     it "produces table data" do
@@ -192,10 +194,10 @@ class Dummy
   describe "#generate_comment" do
     it "produces the expected comment" do
       comment = dummy.generate_comment(
-        warnings: [Danger::Violation.new("This is a warning", false)],
-        errors: [Danger::Violation.new("This is an error", true)],
-        messages: [Danger::Violation.new("This is a message", false)],
-        markdowns: ["*Raw markdown*"],
+        warnings: [violation("This is a warning")],
+        errors: [violation("This is an error", sticky: true)],
+        messages: [violation("This is a message")],
+        markdowns: [markdown("*Raw markdown*")],
         danger_id: "my_danger_id",
         template: "github"
       )
@@ -216,7 +218,7 @@ class Dummy
 
     it "produces the expected comment when there are newlines" do
       comment = dummy.generate_comment(
-        warnings: [Danger::Violation.new("This is a warning\nin two lines", false)],
+        warnings: [violation("This is a warning\nin two lines")],
         errors: [],
         messages: [],
         markdowns: [],
@@ -265,14 +267,14 @@ class Dummy
     end
 
     it "supports markdown code below the summary table" do
-      result = dummy.generate_comment(warnings: violations(["ups"]), markdowns: ["### h3"])
+      result = dummy.generate_comment(warnings: violations(["ups"]), markdowns: violations(["### h3"]))
       expect(result.gsub(/\s+/, "")).to eq(
         '<table><thead><tr><thwidth="50"></th><thwidth="100%"data-danger-table="true"data-kind="Warning">1Warning</th></tr></thead><tbody><tr><td>:warning:</td><tddata-sticky="false">ups</td></tr></tbody></table>###h3<palign="right"data-meta="generated_by_danger">Generatedby:no_entry_sign:<ahref="http://danger.systems/">danger</a></p>'
       )
     end
 
     it "supports markdown only without a table" do
-      result = dummy.generate_comment(markdowns: ["### h3"])
+      result = dummy.generate_comment(markdowns: violations(["### h3"]))
       expect(result.gsub(/\s+/, "")).to eq(
         '###h3<palign="right"data-meta="generated_by_danger">Generatedby:no_entry_sign:<ahref="http://danger.systems/">danger</a></p>'
       )
@@ -317,26 +319,26 @@ class Dummy
     end
 
     it "deduplicates previous violations" do
-      previous_violations = { error: ["an error", "an error"] }
+      previous_violations = { error: violations(["an error", "an error"]) }
       result = dummy.generate_comment(warnings: [], errors: violations([]), messages: [], previous_violations: previous_violations)
       expect(result.scan("an error").size).to eq(1)
     end
 
     it "includes a random compliment" do
-      previous_violations = { error: ["an error"] }
+      previous_violations = { error: violations(["an error"]) }
       result = dummy.generate_comment(warnings: [], errors: violations([]), messages: [], previous_violations: previous_violations)
       expect(result).to match(/:white_check_mark: \w+?/)
     end
 
     it "crosses resolved violations and changes the title" do
-      previous_violations = { error: ["an error"] }
+      previous_violations = { error: violations(["an error"]) }
       result = dummy.generate_comment(warnings: [], errors: [], messages: [], previous_violations: previous_violations)
       expect(result.gsub(/\s+/, "")).to include('<thwidth="100%"data-danger-table="true"data-kind="Error">:white_check_mark:')
       expect(result.gsub(/\s+/, "")).to include('<td>:white_check_mark:</td><tddata-sticky="true"><del>anerror</del></td>')
     end
 
     it "uncrosses violations that were on the list and happened again" do
-      previous_violations = { error: ["an error"] }
+      previous_violations = { error: violations(["an error"]) }
       result = dummy.generate_comment(warnings: [], errors: violations(["an error"]), messages: [], previous_violations: previous_violations)
       expect(result.gsub(/\s+/, "")).to eq(
         '<table><thead><tr><thwidth="50"></th><thwidth="100%"data-danger-table="true"data-kind="Error">1Error</th></tr></thead><tbody><tr><td>:no_entry_sign:</td><tddata-sticky="false">anerror</td></tr></tbody></table><palign="right"data-meta="generated_by_danger">Generatedby:no_entry_sign:<ahref="http://danger.systems/">danger</a></p>'
@@ -344,7 +346,7 @@ class Dummy
     end
 
     it "counts only unresolved violations on the title" do
-      previous_violations = { error: ["an error"] }
+      previous_violations = { error: violations(["an error"]) }
       result = dummy.generate_comment(warnings: [], errors: violations(["another error"]),
                                    messages: [], previous_violations: previous_violations)
       expect(result.gsub(/\s+/, "")).to include('<thwidth="100%"data-danger-table="true"data-kind="Error">1Error</th>')
@@ -362,13 +364,13 @@ class Dummy
     end
 
     it "sets data-sticky to true when a violation is sticky" do
-      sticky_warning = Danger::Violation.new("my warning", true)
+      sticky_warning = Danger::Violation.new("my warning", true, nil, nil)
       result = dummy.generate_comment(warnings: [sticky_warning], errors: [], messages: [])
       expect(result.gsub(/\s+/, "")).to include('tddata-sticky="true"')
     end
 
     it "sets data-sticky to false when a violation is not sticky" do
-      non_sticky_warning = Danger::Violation.new("my warning", false)
+      non_sticky_warning = Danger::Violation.new("my warning", false, nil, nil)
       result = dummy.generate_comment(warnings: [non_sticky_warning], errors: [], messages: [])
       expect(result.gsub(/\s+/, "")).to include('tddata-sticky="false"')
     end
@@ -399,26 +401,30 @@ class Dummy
 
     it "parses a comment with error" do
       comment = comment_fixture("comment_with_error")
-      violations = dummy.parse_comment(comment)
-      expect(violations).to eq({ error: ["Some error"] })
+      results = dummy.parse_comment(comment)
+      expect(results[:error].map(&:message)).to eq(["Some error"])
     end
 
     it "parses a comment with error and warnings" do
       comment = comment_fixture("comment_with_error_and_warnings")
-      violations = dummy.parse_comment(comment)
-      expect(violations).to eq({ error: ["Some error"], warning: ["First warning", "Second warning"] })
+      results = dummy.parse_comment(comment)
+
+      expect(results[:error].map(&:message)).to eq(["Some error"])
+      expect(results[:warning].map(&:message)).to eq(["First warning", "Second warning"])
     end
 
     it "ignores non-sticky violations when parsing a comment" do
       comment = comment_fixture("comment_with_non_sticky")
-      violations = dummy.parse_comment(comment)
-      expect(violations).to eq({ warning: ["First warning"] })
+      results = dummy.parse_comment(comment)
+      expect(results[:warning].map(&:message)).to eq(["First warning"])
     end
 
     it "parses a comment with error and warnings removing strike tag" do
       comment = comment_fixture("comment_with_resolved_violation")
-      violations = dummy.parse_comment(comment)
-      expect(violations).to eq({ error: ["Some error"], warning: ["First warning", "Second warning"] })
+      results = dummy.parse_comment(comment)
+
+      expect(results[:error].map(&:message)).to eq(["Some error"])
+      expect(results[:warning].map(&:message)).to eq(["First warning", "Second warning"])
     end
   end
 end
diff --git a/spec/lib/danger/request_source/github_spec.rb b/spec/lib/danger/request_source/github_spec.rb
new file mode 100644
index 0000000..f6ac48c
--- /dev/null
+++ b/spec/lib/danger/request_source/github_spec.rb
@@ -0,0 +1,240 @@
+# coding: utf-8
+require "danger/request_source/request_source"
+require "danger/ci_source/circle"
+require "danger/ci_source/travis"
+require "danger/danger_core/messages/violation"
+
+describe Danger::RequestSources::GitHub, host: :github do
+  describe "the github host" do
+    it "sets a default GitHub host" do
+      gh_env = { "DANGER_GITHUB_API_TOKEN" => "hi" }
+      g = Danger::RequestSources::GitHub.new(stub_ci, gh_env)
+      expect(g.host).to eql("github.com")
+    end
+
+    it "allows the GitHub host to be overridden" do
+      gh_env = { "DANGER_GITHUB_API_TOKEN" => "hi", "DANGER_GITHUB_HOST" => "git.club-mateusa.com" }
+      g = Danger::RequestSources::GitHub.new(stub_ci, gh_env)
+      expect(g.host).to eql("git.club-mateusa.com")
+    end
+
+    describe "#api_url" do
+      it "allows the GitHub API host to be overridden with `DANGER_GITHUB_API_BASE_URL`" do
+        api_endpoint = "https://git.club-mateusa.com/api/v3/"
+        gh_env = { "DANGER_GITHUB_API_TOKEN" => "hi", "DANGER_GITHUB_API_BASE_URL" => api_endpoint }
+        g = Danger::RequestSources::GitHub.new(stub_ci, gh_env)
+        expect(Octokit.api_endpoint).to eql(api_endpoint)
+      end
+
+      # Old variable for backwards compatibility
+      it "allows the GitHub API host to be overridden with `DANGER_GITHUB_API_HOST`" do
+        api_endpoint = "https://git.club-mateusa.com/api/v3/"
+        gh_env = { "DANGER_GITHUB_API_TOKEN" => "hi", "DANGER_GITHUB_API_HOST" => api_endpoint }
+        g = Danger::RequestSources::GitHub.new(stub_ci, gh_env)
+        expect(Octokit.api_endpoint).to eql(api_endpoint)
+      end
+    end
+  end
+
+  describe "valid server response" do
+    before do
+      gh_env = { "DANGER_GITHUB_API_TOKEN" => "hi" }
+      @g = Danger::RequestSources::GitHub.new(stub_ci, gh_env)
+
+      pr_response = JSON.parse(fixture("github_api/pr_response"), symbolize_names: true)
+      allow(@g.client).to receive(:pull_request).with("artsy/eigen", "800").and_return(pr_response)
+
+      issue_response = JSON.parse(fixture("github_api/issue_response"), symbolize_names: true)
+      allow(@g.client).to receive(:get).with("https://api.github.com/repos/artsy/eigen/issues/800").and_return(issue_response)
+    end
+
+    it "sets its pr_json" do
+      @g.fetch_details
+      expect(@g.pr_json).to be_truthy
+    end
+
+    it "sets its issue_json" do
+      @g.fetch_details
+      expect(@g.issue_json).to be_truthy
+    end
+
+    it "raises an exception when the repo was moved from the git remote" do
+      allow(@g.client).to receive(:pull_request).with("artsy/eigen", "800").and_return({ message: "Moved Permanently" })
+
+      expect do
+        @g.fetch_details
+      end.to raise_error("Repo moved or renamed, make sure to update the git remote".red)
+    end
+
+    it "sets the ignored violations" do
+      @g.fetch_details
+      expect(@g.ignored_violations).to eql(["Developer Specific file shouldn't be changed",
+                                            "Some warning"])
+    end
+
+    describe "#organisation" do
+      it "valid value available" do
+        @g.fetch_details
+        expect(@g.organisation).to eq("artsy")
+      end
+
+      it "no valid value available doesn't crash" do
+        @g.issue_json = nil
+        expect(@g.organisation).to eq(nil)
+      end
+    end
+
+    describe "#file_url" do
+      it "returns a valid URL with the minimum parameters" do
+        url = @g.file_url(repository: "danger",
+                                path: "path/Dangerfile")
+        expect(url).to eq("https://raw.githubusercontent.com//danger/master/path/Dangerfile")
+      end
+
+      it "returns a valid URL with more parameters" do
+        url = @g.file_url(repository: "danger",
+                        organisation: "org_yo",
+                              branch: "yolo_branch",
+                                path: "path/Dangerfile")
+        expect(url).to eq("https://raw.githubusercontent.com/org_yo/danger/yolo_branch/path/Dangerfile")
+      end
+    end
+
+    describe "status message" do
+      it "Shows a success message when no errors/warnings" do
+        message = @g.generate_description(warnings: [], errors: [])
+        expect(message).to start_with("All green.")
+      end
+
+      it "Shows an error messages when there are errors" do
+        message = @g.generate_description(warnings: violations([1, 2, 3]), errors: [])
+        expect(message).to eq("‚ö† 3 Warnings. Don't worry, everything is fixable.")
+      end
+
+      it "Shows an error message when errors and warnings" do
+        message = @g.generate_description(warnings: violations([1, 2]), errors: violations([1, 2, 3]))
+        expect(message).to eq("‚ö† 3 Errors. 2 Warnings. Don't worry, everything is fixable.")
+      end
+
+      it "Deals with singualars in messages when errors and warnings" do
+        message = @g.generate_description(warnings: violations([1]), errors: violations([1]))
+        expect(message).to eq("‚ö† 1 Error. 1 Warning. Don't worry, everything is fixable.")
+      end
+    end
+
+    describe "commit status update" do
+      before do
+        stub_request(:post, "https://git.club-mateusa.com/api/v3/repos/artsy/eigen/statuses/").to_return status: 200
+      end
+
+      it "fails when no head commit is set" do
+        @g.pr_json = { base: { sha: "" }, head: { sha: "" } }
+        expect do
+          @g.submit_pull_request_status!
+        end.to raise_error("Couldn't find a commit to update its status".red)
+      end
+    end
+
+    describe "issue creation" do
+      before do
+        @g.pr_json = { base: { sha: "" }, head: { sha: "" } }
+        allow(@g).to receive(:submit_pull_request_status!).and_return(true)
+      end
+
+      it "creates a comment if no danger comments exist" do
+        comments = []
+        allow(@g.client).to receive(:issue_comments).with("artsy/eigen", "800").and_return(comments)
+
+        body = @g.generate_comment(warnings: violations(["hi"]), errors: [], messages: [])
+        expect(@g.client).to receive(:add_comment).with("artsy/eigen", "800", body).and_return({})
+
+        @g.update_pull_request!(warnings: violations(["hi"]), errors: [], messages: [])
+      end
+
+      it "updates the issue if no danger comments exist" do
+        comments = [{ body: "generated_by_danger", id: "12" }]
+        allow(@g.client).to receive(:issue_comments).with("artsy/eigen", "800").and_return(comments)
+
+        body = @g.generate_comment(warnings: violations(["hi"]), errors: [], messages: [])
+        expect(@g.client).to receive(:update_comment).with("artsy/eigen", "12", body).and_return({})
+
+        @g.update_pull_request!(warnings: violations(["hi"]), errors: [], messages: [])
+      end
+
+      it "updates the issue if no danger comments exist and a custom danger_id is provided" do
+        comments = [{ body: "generated_by_another_danger", id: "12" }]
+        allow(@g.client).to receive(:issue_comments).with("artsy/eigen", "800").and_return(comments)
+
+        body = @g.generate_comment(warnings: violations(["hi"]), errors: [], messages: [], danger_id: "another_danger")
+        expect(@g.client).to receive(:update_comment).with("artsy/eigen", "12", body).and_return({})
+
+        @g.update_pull_request!(warnings: violations(["hi"]), errors: [], messages: [], danger_id: "another_danger")
+      end
+
+      it "deletes existing comments if danger doesnt need to say anything" do
+        comments = [{ body: "generated_by_danger", id: "12" }]
+        allow(@g.client).to receive(:issue_comments).with("artsy/eigen", "800").and_return(comments)
+
+        expect(@g.client).to receive(:delete_comment).with("artsy/eigen", "12").and_return({})
+        @g.update_pull_request!(warnings: [], errors: [], messages: [])
+      end
+
+      it "deletes existing comments if danger doesnt need to say anything and a custom danger_id is provided" do
+        comments = [{ body: "generated_by_another_danger", id: "12" }]
+        allow(@g.client).to receive(:issue_comments).with("artsy/eigen", "800").and_return(comments)
+
+        expect(@g.client).to receive(:delete_comment).with("artsy/eigen", "12").and_return({})
+        @g.update_pull_request!(warnings: [], errors: [], messages: [], danger_id: "another_danger")
+      end
+
+      it "updates the comment if danger doesnt need to say anything but there are sticky violations" do
+        comments = [{ body: "generated_by_danger", id: "12" }]
+        allow(@g).to receive(:parse_comment).and_return({ errors: ["an error"] })
+        allow(@g.client).to receive(:issue_comments).with("artsy/eigen", "800").and_return(comments)
+
+        expect(@g.client).to receive(:update_comment).with("artsy/eigen", "12", any_args).and_return({})
+        @g.update_pull_request!(warnings: [], errors: [], messages: [])
+      end
+    end
+
+    describe "#parse_message_from_row" do
+      it "handles pulling out links that include the file / line when in the main Danger comment" do
+        body = '<a href="https://github.com/artsy/eigen/blob/8e5d0bab431839a7046b2f7d5cd5ccb91677fe23/CHANGELOG.md#L1">CHANGELOG.md#L1</a> - Testing inline docs'
+
+        v = @g.parse_message_from_row(body)
+        expect(v.file).to eq("CHANGELOG.md")
+        expect(v.line).to eq(1)
+        expect(v.message).to include("- Testing inline docs")
+      end
+
+      it "handles pulling out file info from an inline Danger comment" do
+        body = '<span data-href="https://github.com/artsy/eigen/blob/8e5d0bab431839a7046b2f7d5cd5ccb91677fe23/CHANGELOG.md#L1"/>Testing inline docs'
+        v = @g.parse_message_from_row(body)
+        expect(v.file).to eq("CHANGELOG.md")
+        expect(v.line).to eq(1)
+        expect(v.message).to include("Testing inline docs")
+      end
+    end
+
+    let(:main_issue_id) { 76537315 }
+    let(:inline_issue_id_1) { 76537316 }
+    let(:inline_issue_id_2) { 76535362 }
+
+    describe "inline issues" do
+      it "deletes all inline comments if there are no violations at all" do
+        comments = JSON.parse(fixture("github_api/inline_comments"), symbolize_names: true)
+        allow(@g.client).to receive(:issue_comments).with("artsy/eigen", "800").and_return(comments)
+
+        # Main
+        allow(@g.client).to receive(:delete_comment).with("artsy/eigen", main_issue_id)
+        # Inline Issues
+        allow(@g.client).to receive(:delete_comment).with("artsy/eigen", inline_issue_id_1)
+        allow(@g.client).to receive(:delete_comment).with("artsy/eigen", inline_issue_id_2)
+
+        allow(@g).to receive(:submit_pull_request_status!)
+
+        @g.update_pull_request!(warnings: [], errors: [], messages: [])
+      end
+    end
+  end
+end
diff --git a/spec/lib/danger/request_source/gitlab_spec.rb b/spec/lib/danger/request_source/gitlab_spec.rb
new file mode 100644
index 0000000..e070082
--- /dev/null
+++ b/spec/lib/danger/request_source/gitlab_spec.rb
@@ -0,0 +1,218 @@
+# coding: utf-8
+require "erb"
+
+require "danger/request_source/request_source"
+
+describe Danger::RequestSources::GitLab, host: :gitlab do
+  let(:env) { stub_env }
+  let(:g) { Danger::RequestSources::GitLab.new(stub_ci, env) }
+
+  describe "the GitLab host" do
+    it "sets the default GitLab host" do
+      expect(g.host).to eql("gitlab.com")
+    end
+
+    it "allows the GitLab host to be overidden" do
+      env["DANGER_GITLAB_HOST"] = "gitlab.example.com"
+      expect(g.host).to eql("gitlab.example.com")
+    end
+  end
+
+  describe "the GitLab API endpoint" do
+    it "sets the default GitLab API endpoint" do
+      expect(g.endpoint).to eql("https://gitlab.com/api/v3")
+    end
+
+    it "allows the GitLab API endpoint to be overidden with `DANGER_GITLAB_API_BASE_URL`" do
+      env["DANGER_GITLAB_API_BASE_URL"] = "https://gitlab.example.com/api/v3"
+      expect(g.endpoint).to eql("https://gitlab.example.com/api/v3")
+    end
+  end
+
+  describe "the GitLab API client" do
+    it "sets the provide token" do
+      env["DANGER_GITLAB_API_TOKEN"] = "token"
+      expect(g.client.private_token).to eql("token")
+    end
+
+    it "set the default API endpoint" do
+      expect(g.client.endpoint).to eql("https://gitlab.com/api/v3")
+    end
+
+    it "respects overriding the API endpoint" do
+      env["DANGER_GITLAB_API_BASE_URL"] = "https://gitlab.example.com/api/v3"
+      expect(g.client.endpoint).to eql("https://gitlab.example.com/api/v3")
+    end
+  end
+
+  describe "validation" do
+    it "validates as an API source" do
+      expect(g.validates_as_api_source?).to be_truthy
+    end
+
+    it "does no validate as an API source when the API token is empty" do
+      env = stub_env
+      env["DANGER_GITLAB_API_TOKEN"] = ""
+      g = Danger::RequestSources::GitLab.new(stub_ci, env)
+
+      expect(g.validates_as_api_source?).to be_falsey
+    end
+
+    it "does no validate as an API source when there is no API token" do
+      env = stub_env
+      env.delete("DANGER_GITLAB_API_TOKEN")
+      g = Danger::RequestSources::GitLab.new(stub_ci, env)
+
+      expect(g.validates_as_api_source?).to be_falsey
+    end
+  end
+
+  describe "scm" do
+    it "Sets up the scm" do
+      expect(g.scm).to be_kind_of(Danger::GitRepo)
+    end
+  end
+
+  describe "valid server response" do
+    before do
+      stub_merge_request(
+        "merge_request_593728_response",
+        "k0nserv/danger-test",
+        593_728
+      )
+      stub_merge_request_commits(
+        "merge_request_593728_commits_response",
+        "k0nserv/danger-test",
+        593_728
+      )
+      @comments_stub = stub_merge_request_comments(
+        "merge_request_593728_comments_response",
+        "k0nserv/danger-test",
+        593_728
+      )
+    end
+
+    it "determines the correct base_commit" do
+      g.fetch_details
+      expect(g.scm).to receive(:exec)
+        .with("rev-parse adae7c389e1d261da744565fdd5fdebf16e559d1^1")
+        .and_return("0e4db308b6579f7cc733e5a354e026b272e1c076")
+
+      expect(g.base_commit).to eq("0e4db308b6579f7cc733e5a354e026b272e1c076")
+    end
+
+    it "setups the danger branches" do
+      g.fetch_details
+      expect(g.scm).to receive(:head_commit).and_return("345e74fabb2fecea93091e8925b1a7a208b48ba6")
+      expect(g).to receive(:base_commit).and_return("0e4db308b6579f7cc733e5a354e026b272e1c076")
+
+      expect(g.scm).to receive(:exec)
+        .with("branch danger_head 345e74fabb2fecea93091e8925b1a7a208b48ba6")
+      expect(g.scm).to receive(:exec)
+        .with("branch danger_base 0e4db308b6579f7cc733e5a354e026b272e1c076")
+
+      g.setup_danger_branches
+    end
+
+    it "set its mr_json" do
+      g.fetch_details
+      expect(g.mr_json).to be_truthy
+    end
+
+    it "sets its commits_json" do
+      g.fetch_details
+      expect(g.commits_json).to be_truthy
+    end
+
+    it "sets its ignored_violations_from_pr" do
+      g.fetch_details
+      expect(g.ignored_violations).to eq(
+        [
+          "Developer specific files shouldn't be changed",
+          "Testing"
+        ]
+      )
+    end
+
+    describe "#update_pull_request!" do
+      it "creates a new comment when there is not one already" do
+        body = g.generate_comment(
+          warnings: violations(["Test warning"]),
+          errors: violations(["Test error"]),
+          messages: violations(["Test message"]),
+          template: "gitlab"
+        )
+        stub_request(:post, "https://gitlab.com/api/v3/projects/k0nserv%2Fdanger-test/merge_requests/593728/notes").with(
+          body: "body=#{ERB::Util.url_encode(body)}",
+          headers: expected_headers
+        ).to_return(status: 200, body: "", headers: {})
+        g.update_pull_request!(
+          warnings: violations(["Test warning"]),
+          errors: violations(["Test error"]),
+          messages: violations(["Test message"])
+        )
+      end
+
+      context "existing comment" do
+        before do
+          remove_request_stub(@comments_stub)
+
+          @comments_stub = stub_merge_request_comments(
+            "merge_request_593728_comments_existing_danger_comment_response",
+            "k0nserv/danger-test",
+            593_728
+          )
+        end
+
+        it "updates the existing comment instead of creating a new one" do
+          allow(g).to receive(:random_compliment).and_return("random compliment")
+          body = g.generate_comment(
+            warnings: violations(["New Warning"]),
+            errors: [],
+            messages: [],
+            previous_violations: {
+              warning: [],
+              error: violations(["Test error"]),
+              message: []
+            },
+            template: "gitlab"
+          )
+
+          stub_request(:put, "https://gitlab.com/api/v3/projects/k0nserv%2Fdanger-test/merge_requests/593728/notes/13471894").with(
+            body: "body=#{ERB::Util.url_encode(body)}",
+            headers: expected_headers
+          ).to_return(status: 200, body: "", headers: {})
+          g.update_pull_request!(
+            warnings: violations(["New Warning"]),
+            errors: [],
+            messages: []
+          )
+        end
+      end
+
+      context "existing comment with no sticky messages" do
+        before do
+          remove_request_stub(@comments_stub)
+
+          @comments_stub = stub_merge_request_comments(
+            "merge_request_593728_comments_no_stickies_response",
+            "k0nserv/danger-test",
+            593_728
+          )
+        end
+
+        it "removes the previous danger comment if there are no new messages" do
+          stub_request(:delete, "https://gitlab.com/api/v3/projects/k0nserv%2Fdanger-test/merge_requests/593728/notes/13471894").with(
+            headers: expected_headers
+          )
+
+          g.update_pull_request!(
+            warnings: [],
+            errors: [],
+            messages: []
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/spec/lib/danger/request_source/request_source_spec.rb b/spec/lib/danger/request_source/request_source_spec.rb
new file mode 100644
index 0000000..705a137
--- /dev/null
+++ b/spec/lib/danger/request_source/request_source_spec.rb
@@ -0,0 +1,34 @@
+require "danger/request_source/github"
+
+describe Danger::RequestSources::RequestSource, host: :github do
+  describe "the base request source" do
+    it "validates when passed a corresponding repository" do
+      git_mock = Danger::GitRepo.new
+      allow(git_mock).to receive(:exec).with("remote show origin -n").and_return("Fetch URL: git@github.com:artsy/eigen.git")
+
+      g = stub_request_source
+      g.scm = git_mock
+      expect(g.validates_as_ci?).to be true
+    end
+
+    it "validates when passed a corresponding repository with custom host" do
+      git_mock = Danger::GitRepo.new
+
+      gh_env = { "DANGER_GITHUB_API_TOKEN" => "hi", "DANGER_GITHUB_HOST" => "git.club-mateusa.com" }
+      g = Danger::RequestSources::GitHub.new(stub_ci, gh_env)
+      g.scm = git_mock
+
+      allow(git_mock).to receive(:exec).with("remote show origin -n").and_return("Fetch URL: git@git.club-mateusa.com:artsy/eigen.git")
+      expect(g.validates_as_ci?).to be true
+    end
+
+    it 'doesn\'t validate when passed a wrong repository' do
+      git_mock = Danger::GitRepo.new
+      allow(git_mock).to receive(:exec).with("remote show origin -n").and_return("Fetch URL: git@bitbucket.org:artsy/eigen.git")
+
+      g = stub_request_source
+      g.scm = git_mock
+      expect(g.validates_as_ci?).to be false
+    end
+  end
+end
diff --git a/spec/lib/danger/request_sources/github_spec.rb b/spec/lib/danger/request_sources/github_spec.rb
deleted file mode 100644
index 09929a5..0000000
--- a/spec/lib/danger/request_sources/github_spec.rb
+++ /dev/null
@@ -1,217 +0,0 @@
-# coding: utf-8
-require "danger/request_source/request_source"
-require "danger/ci_source/circle"
-require "danger/ci_source/travis"
-require "danger/danger_core/violation"
-
-describe Danger::RequestSources::GitHub, host: :github do
-  describe "the github host" do
-    it "sets a default GitHub host" do
-      gh_env = { "DANGER_GITHUB_API_TOKEN" => "hi" }
-      g = Danger::RequestSources::GitHub.new(stub_ci, gh_env)
-      expect(g.host).to eql("github.com")
-    end
-
-    it "allows the GitHub host to be overridden" do
-      gh_env = { "DANGER_GITHUB_API_TOKEN" => "hi", "DANGER_GITHUB_HOST" => "git.club-mateusa.com" }
-      g = Danger::RequestSources::GitHub.new(stub_ci, gh_env)
-      expect(g.host).to eql("git.club-mateusa.com")
-    end
-
-    describe "#api_url" do
-      it "allows the GitHub API host to be overridden with `DANGER_GITHUB_API_BASE_URL`" do
-        api_endpoint = "https://git.club-mateusa.com/api/v3/"
-        gh_env = { "DANGER_GITHUB_API_TOKEN" => "hi", "DANGER_GITHUB_API_BASE_URL" => api_endpoint }
-        g = Danger::RequestSources::GitHub.new(stub_ci, gh_env)
-        expect(Octokit.api_endpoint).to eql(api_endpoint)
-      end
-
-      # Old variable for backwards compatibility
-      it "allows the GitHub API host to be overridden with `DANGER_GITHUB_API_HOST`" do
-        api_endpoint = "https://git.club-mateusa.com/api/v3/"
-        gh_env = { "DANGER_GITHUB_API_TOKEN" => "hi", "DANGER_GITHUB_API_HOST" => api_endpoint }
-        g = Danger::RequestSources::GitHub.new(stub_ci, gh_env)
-        expect(Octokit.api_endpoint).to eql(api_endpoint)
-      end
-    end
-  end
-
-  describe "valid server response" do
-    before do
-      gh_env = { "DANGER_GITHUB_API_TOKEN" => "hi" }
-      @g = Danger::RequestSources::GitHub.new(stub_ci, gh_env)
-
-      pr_response = JSON.parse(fixture("github_api/pr_response"), symbolize_names: true)
-      allow(@g.client).to receive(:pull_request).with("artsy/eigen", "800").and_return(pr_response)
-
-      issue_response = JSON.parse(fixture("github_api/issue_response"), symbolize_names: true)
-      allow(@g.client).to receive(:get).with("https://api.github.com/repos/artsy/eigen/issues/800").and_return(issue_response)
-    end
-
-    it "sets its pr_json" do
-      @g.fetch_details
-      expect(@g.pr_json).to be_truthy
-    end
-
-    it "sets its issue_json" do
-      @g.fetch_details
-      expect(@g.issue_json).to be_truthy
-    end
-
-    it "raises an exception when the repo was moved from the git remote" do
-      allow(@g.client).to receive(:pull_request).with("artsy/eigen", "800").and_return({ message: "Moved Permanently" })
-
-      expect do
-        @g.fetch_details
-      end.to raise_error("Repo moved or renamed, make sure to update the git remote".red)
-    end
-
-    it "sets the ignored violations" do
-      @g.fetch_details
-      expect(@g.ignored_violations).to eql(["Developer Specific file shouldn't be changed",
-                                            "Some warning"])
-    end
-
-    describe "#organisation" do
-      it "valid value available" do
-        @g.fetch_details
-        expect(@g.organisation).to eq("artsy")
-      end
-
-      it "no valid value available doesn't crash" do
-        @g.issue_json = nil
-        expect(@g.organisation).to eq(nil)
-      end
-    end
-
-    describe "#file_url" do
-      it "returns a valid URL with the minimum parameters" do
-        url = @g.file_url(repository: "danger",
-                                path: "path/Dangerfile")
-        expect(url).to eq("https://raw.githubusercontent.com//danger/master/path/Dangerfile")
-      end
-
-      it "returns a valid URL with more parameters" do
-        url = @g.file_url(repository: "danger",
-                        organisation: "org_yo",
-                              branch: "yolo_branch",
-                                path: "path/Dangerfile")
-        expect(url).to eq("https://raw.githubusercontent.com/org_yo/danger/yolo_branch/path/Dangerfile")
-      end
-    end
-
-    # TODO: Move to the plugin
-    #
-    xdescribe "DSL Attributes" do
-      it "sets the right commit sha" do
-        @g.fetch_details
-
-        expect(@g.pr_json[:base][:sha]).to eql(@g.base_commit)
-        expect(@g.pr_json[:head][:sha]).to eql(@g.head_commit)
-        expect(@g.pr_json[:base][:ref]).to eql(@g.branch_for_merge)
-      end
-
-      it "sets the right labels" do
-        @g.fetch_details
-        expect(@g.pr_labels).to eql(["D:2", "Maintenance Work"])
-      end
-    end
-
-    describe "status message" do
-      it "Shows a success message when no errors/warnings" do
-        message = @g.generate_description(warnings: [], errors: [])
-        expect(message).to start_with("All green.")
-      end
-
-      it "Shows an error messages when there are errors" do
-        message = @g.generate_description(warnings: violations([1, 2, 3]), errors: [])
-        expect(message).to eq("‚ö† 3 Warnings. Don't worry, everything is fixable.")
-      end
-
-      it "Shows an error message when errors and warnings" do
-        message = @g.generate_description(warnings: violations([1, 2]), errors: violations([1, 2, 3]))
-        expect(message).to eq("‚ö† 3 Errors. 2 Warnings. Don't worry, everything is fixable.")
-      end
-
-      it "Deals with singualars in messages when errors and warnings" do
-        message = @g.generate_description(warnings: violations([1]), errors: violations([1]))
-        expect(message).to eq("‚ö† 1 Error. 1 Warning. Don't worry, everything is fixable.")
-      end
-    end
-
-    describe "commit status update" do
-      before do
-        stub_request(:post, "https://git.club-mateusa.com/api/v3/repos/artsy/eigen/statuses/").to_return status: 200
-      end
-
-      it "fails when no head commit is set" do
-        @g.pr_json = { base: { sha: "" }, head: { sha: "" } }
-        expect do
-          @g.submit_pull_request_status!
-        end.to raise_error("Couldn't find a commit to update its status".red)
-      end
-    end
-
-    describe "issue creation" do
-      before do
-        @g.pr_json = { base: { sha: "" }, head: { sha: "" } }
-        allow(@g).to receive(:submit_pull_request_status!).and_return(true)
-      end
-
-      it "creates a comment if no danger comments exist" do
-        comments = []
-        allow(@g.client).to receive(:issue_comments).with("artsy/eigen", "800").and_return(comments)
-
-        body = @g.generate_comment(warnings: violations(["hi"]), errors: [], messages: [])
-        expect(@g.client).to receive(:add_comment).with("artsy/eigen", "800", body).and_return({})
-
-        @g.update_pull_request!(warnings: violations(["hi"]), errors: [], messages: [])
-      end
-
-      it "updates the issue if no danger comments exist" do
-        comments = [{ body: "generated_by_danger", id: "12" }]
-        allow(@g.client).to receive(:issue_comments).with("artsy/eigen", "800").and_return(comments)
-
-        body = @g.generate_comment(warnings: violations(["hi"]), errors: [], messages: [])
-        expect(@g.client).to receive(:update_comment).with("artsy/eigen", "12", body).and_return({})
-
-        @g.update_pull_request!(warnings: violations(["hi"]), errors: [], messages: [])
-      end
-
-      it "updates the issue if no danger comments exist and a custom danger_id is provided" do
-        comments = [{ body: "generated_by_another_danger", id: "12" }]
-        allow(@g.client).to receive(:issue_comments).with("artsy/eigen", "800").and_return(comments)
-
-        body = @g.generate_comment(warnings: violations(["hi"]), errors: [], messages: [], danger_id: "another_danger")
-        expect(@g.client).to receive(:update_comment).with("artsy/eigen", "12", body).and_return({})
-
-        @g.update_pull_request!(warnings: violations(["hi"]), errors: [], messages: [], danger_id: "another_danger")
-      end
-
-      it "deletes existing comments if danger doesnt need to say anything" do
-        comments = [{ body: "generated_by_danger", id: "12" }]
-        allow(@g.client).to receive(:issue_comments).with("artsy/eigen", "800").and_return(comments)
-
-        expect(@g.client).to receive(:delete_comment).with("artsy/eigen", "12").and_return({})
-        @g.update_pull_request!(warnings: [], errors: [], messages: [])
-      end
-
-      it "deletes existing comments if danger doesnt need to say anything and a custom danger_id is provided" do
-        comments = [{ body: "generated_by_another_danger", id: "12" }]
-        allow(@g.client).to receive(:issue_comments).with("artsy/eigen", "800").and_return(comments)
-
-        expect(@g.client).to receive(:delete_comment).with("artsy/eigen", "12").and_return({})
-        @g.update_pull_request!(warnings: [], errors: [], messages: [], danger_id: "another_danger")
-      end
-
-      it "updates the comment if danger doesnt need to say anything but there are sticky violations" do
-        comments = [{ body: "generated_by_danger", id: "12" }]
-        allow(@g).to receive(:parse_comment).and_return({ errors: ["an error"] })
-        allow(@g.client).to receive(:issue_comments).with("artsy/eigen", "800").and_return(comments)
-
-        expect(@g.client).to receive(:update_comment).with("artsy/eigen", "12", any_args).and_return({})
-        @g.update_pull_request!(warnings: [], errors: [], messages: [])
-      end
-    end
-  end
-end
diff --git a/spec/lib/danger/request_sources/gitlab_spec.rb b/spec/lib/danger/request_sources/gitlab_spec.rb
deleted file mode 100644
index 085caae..0000000
--- a/spec/lib/danger/request_sources/gitlab_spec.rb
+++ /dev/null
@@ -1,218 +0,0 @@
-# coding: utf-8
-require "erb"
-
-require "danger/request_source/request_source"
-
-describe Danger::RequestSources::GitLab, host: :gitlab do
-  let(:env) { stub_env }
-  let(:g) { Danger::RequestSources::GitLab.new(stub_ci, env) }
-
-  describe "the GitLab host" do
-    it "sets the default GitLab host" do
-      expect(g.host).to eql("gitlab.com")
-    end
-
-    it "allows the GitLab host to be overidden" do
-      env["DANGER_GITLAB_HOST"] = "gitlab.example.com"
-      expect(g.host).to eql("gitlab.example.com")
-    end
-  end
-
-  describe "the GitLab API endpoint" do
-    it "sets the default GitLab API endpoint" do
-      expect(g.endpoint).to eql("https://gitlab.com/api/v3")
-    end
-
-    it "allows the GitLab API endpoint to be overidden with `DANGER_GITLAB_API_BASE_URL`" do
-      env["DANGER_GITLAB_API_BASE_URL"] = "https://gitlab.example.com/api/v3"
-      expect(g.endpoint).to eql("https://gitlab.example.com/api/v3")
-    end
-  end
-
-  describe "the GitLab API client" do
-    it "sets the provide token" do
-      env["DANGER_GITLAB_API_TOKEN"] = "token"
-      expect(g.client.private_token).to eql("token")
-    end
-
-    it "set the default API endpoint" do
-      expect(g.client.endpoint).to eql("https://gitlab.com/api/v3")
-    end
-
-    it "respects overriding the API endpoint" do
-      env["DANGER_GITLAB_API_BASE_URL"] = "https://gitlab.example.com/api/v3"
-      expect(g.client.endpoint).to eql("https://gitlab.example.com/api/v3")
-    end
-  end
-
-  describe "validation" do
-    it "validates as an API source" do
-      expect(g.validates_as_api_source?).to be_truthy
-    end
-
-    it "does no validate as an API source when the API token is empty" do
-      env = stub_env
-      env["DANGER_GITLAB_API_TOKEN"] = ""
-      g = Danger::RequestSources::GitLab.new(stub_ci, env)
-
-      expect(g.validates_as_api_source?).to be_falsey
-    end
-
-    it "does no validate as an API source when there is no API token" do
-      env = stub_env
-      env.delete("DANGER_GITLAB_API_TOKEN")
-      g = Danger::RequestSources::GitLab.new(stub_ci, env)
-
-      expect(g.validates_as_api_source?).to be_falsey
-    end
-  end
-
-  describe "scm" do
-    it "Sets up the scm" do
-      expect(g.scm).to be_kind_of(Danger::GitRepo)
-    end
-  end
-
-  describe "valid server response" do
-    before do
-      stub_merge_request(
-        "merge_request_593728_response",
-        "k0nserv/danger-test",
-        593_728
-      )
-      stub_merge_request_commits(
-        "merge_request_593728_commits_response",
-        "k0nserv/danger-test",
-        593_728
-      )
-      @comments_stub = stub_merge_request_comments(
-        "merge_request_593728_comments_response",
-        "k0nserv/danger-test",
-        593_728
-      )
-    end
-
-    it "determines the correct base_commit" do
-      g.fetch_details
-      expect(g.scm).to receive(:exec)
-        .with("rev-parse adae7c389e1d261da744565fdd5fdebf16e559d1^1")
-        .and_return("0e4db308b6579f7cc733e5a354e026b272e1c076")
-
-      expect(g.base_commit).to eq("0e4db308b6579f7cc733e5a354e026b272e1c076")
-    end
-
-    it "setups the danger branches" do
-      g.fetch_details
-      expect(g.scm).to receive(:head_commit).and_return("345e74fabb2fecea93091e8925b1a7a208b48ba6")
-      expect(g).to receive(:base_commit).and_return("0e4db308b6579f7cc733e5a354e026b272e1c076")
-
-      expect(g.scm).to receive(:exec)
-        .with("branch danger_head 345e74fabb2fecea93091e8925b1a7a208b48ba6")
-      expect(g.scm).to receive(:exec)
-        .with("branch danger_base 0e4db308b6579f7cc733e5a354e026b272e1c076")
-
-      g.setup_danger_branches
-    end
-
-    it "set its mr_json" do
-      g.fetch_details
-      expect(g.mr_json).to be_truthy
-    end
-
-    it "sets its commits_json" do
-      g.fetch_details
-      expect(g.commits_json).to be_truthy
-    end
-
-    it "sets its ignored_violations_from_pr" do
-      g.fetch_details
-      expect(g.ignored_violations).to eq(
-        [
-          "Developer specific files shouldn't be changed",
-          "Testing"
-        ]
-      )
-    end
-
-    describe "#update_pull_request!" do
-      it "creates a new comment when there is not one already" do
-        body = g.generate_comment(
-          warnings: violations(["Test warning"]),
-          errors: violations(["Test error"]),
-          messages: violations(["Test message"]),
-          template: "gitlab"
-        )
-        stub_request(:post, "https://gitlab.com/api/v3/projects/k0nserv%2Fdanger-test/merge_requests/593728/notes").with(
-          body: "body=#{ERB::Util.url_encode(body)}",
-          headers: expected_headers
-        ).to_return(status: 200, body: "", headers: {})
-        g.update_pull_request!(
-          warnings: violations(["Test warning"]),
-          errors: violations(["Test error"]),
-          messages: violations(["Test message"])
-        )
-      end
-
-      context "existing comment" do
-        before do
-          remove_request_stub(@comments_stub)
-
-          @comments_stub = stub_merge_request_comments(
-            "merge_request_593728_comments_existing_danger_comment_response",
-            "k0nserv/danger-test",
-            593_728
-          )
-        end
-
-        it "updates the existing comment instead of creating a new one" do
-          allow(g).to receive(:random_compliment).and_return("random compliment")
-          body = g.generate_comment(
-            warnings: violations(["New Warning"]),
-            errors: [],
-            messages: [],
-            previous_violations: {
-              warning: [],
-              error: ["Test error"],
-              message: []
-            },
-            template: "gitlab"
-          )
-
-          stub_request(:put, "https://gitlab.com/api/v3/projects/k0nserv%2Fdanger-test/merge_requests/593728/notes/13471894").with(
-            body: "body=#{ERB::Util.url_encode(body)}",
-            headers: expected_headers
-          ).to_return(status: 200, body: "", headers: {})
-          g.update_pull_request!(
-            warnings: violations(["New Warning"]),
-            errors: [],
-            messages: []
-          )
-        end
-      end
-
-      context "existing comment with no sticky messages" do
-        before do
-          remove_request_stub(@comments_stub)
-
-          @comments_stub = stub_merge_request_comments(
-            "merge_request_593728_comments_no_stickies_response",
-            "k0nserv/danger-test",
-            593_728
-          )
-        end
-
-        it "removes the previous danger comment if there are no new messages" do
-          stub_request(:delete, "https://gitlab.com/api/v3/projects/k0nserv%2Fdanger-test/merge_requests/593728/notes/13471894").with(
-            headers: expected_headers
-          )
-
-          g.update_pull_request!(
-            warnings: [],
-            errors: [],
-            messages: []
-          )
-        end
-      end
-    end
-  end
-end
diff --git a/spec/lib/danger/request_sources/request_source_spec.rb b/spec/lib/danger/request_sources/request_source_spec.rb
deleted file mode 100644
index 705a137..0000000
--- a/spec/lib/danger/request_sources/request_source_spec.rb
+++ /dev/null
@@ -1,34 +0,0 @@
-require "danger/request_source/github"
-
-describe Danger::RequestSources::RequestSource, host: :github do
-  describe "the base request source" do
-    it "validates when passed a corresponding repository" do
-      git_mock = Danger::GitRepo.new
-      allow(git_mock).to receive(:exec).with("remote show origin -n").and_return("Fetch URL: git@github.com:artsy/eigen.git")
-
-      g = stub_request_source
-      g.scm = git_mock
-      expect(g.validates_as_ci?).to be true
-    end
-
-    it "validates when passed a corresponding repository with custom host" do
-      git_mock = Danger::GitRepo.new
-
-      gh_env = { "DANGER_GITHUB_API_TOKEN" => "hi", "DANGER_GITHUB_HOST" => "git.club-mateusa.com" }
-      g = Danger::RequestSources::GitHub.new(stub_ci, gh_env)
-      g.scm = git_mock
-
-      allow(git_mock).to receive(:exec).with("remote show origin -n").and_return("Fetch URL: git@git.club-mateusa.com:artsy/eigen.git")
-      expect(g.validates_as_ci?).to be true
-    end
-
-    it 'doesn\'t validate when passed a wrong repository' do
-      git_mock = Danger::GitRepo.new
-      allow(git_mock).to receive(:exec).with("remote show origin -n").and_return("Fetch URL: git@bitbucket.org:artsy/eigen.git")
-
-      g = stub_request_source
-      g.scm = git_mock
-      expect(g.validates_as_ci?).to be false
-    end
-  end
-end
diff --git a/spec/spec_helper.rb b/spec/spec_helper.rb
index d82e990..81e9dbe 100644
--- a/spec/spec_helper.rb
+++ b/spec/spec_helper.rb
@@ -69,10 +69,18 @@ def diff_fixture(file)
   File.read("spec/fixtures/#{file}.diff")
 end
 
-def violation(message)
-  Danger::Violation.new(message, false)
+def violation(message, sticky: false)
+  Danger::Violation.new(message, sticky, nil, nil)
 end
 
-def violations(messages)
-  messages.map { |s| violation(s) }
+def violations(messages, sticky: false)
+  messages.map { |s| violation(s, sticky: sticky) }
+end
+
+def markdown(message)
+  Danger::Markdown.new(message, nil, nil)
+end
+
+def markdowns(messages)
+  messages.map { |s| markdown(s) }
 end
